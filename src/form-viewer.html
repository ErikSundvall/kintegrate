<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Kintegrate - Form Viewer</title>
    <!-- Better Form Renderer files are loaded dynamically after Service Worker is ready -->
    <!-- JSZip for loading form packages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" 
            crossorigin="anonymous"></script>
    <style>
      * {
        box-sizing: border-box;
      }
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }
      body {
        display: flex;
        flex-direction: column;
      }
      #header {
        background: #f5f5f5;
        border-bottom: 1px solid #ddd;
        padding: 8px 16px;
        display: flex;
        align-items: center;
        gap: 16px;
        flex-shrink: 0;
      }
      #header h1 {
        margin: 0;
        font-size: 1.2em;
        font-weight: 500;
      }
      #form-name {
        color: #666;
        font-size: 0.9em;
      }
      #sync-indicator {
        font-size: 0.8em;
        padding: 2px 8px;
        border-radius: 4px;
        margin-left: 8px;
      }
      #sync-indicator.sync-off {
        background: #f5f5f5;
        color: #666;
      }
      #sync-indicator.sync-on {
        background: #4CAF50;
        color: white;
      }
      #status {
        margin-left: auto;
        font-size: 0.85em;
        color: #666;
      }
      #status.error {
        color: #c00;
      }
      #status.success {
        color: #080;
      }
      #test-mode-badge {
        margin-left: 8px;
        font-size: 0.75em;
        padding: 2px 6px;
        border-radius: 4px;
        background: #ffb300;
        color: #1f1f1f;
        font-weight: 600;
        letter-spacing: 0.02em;
      }
      #toolbar {
        background: #fafafa;
        border-bottom: 1px solid #eee;
        padding: 8px 16px;
        display: flex;
        gap: 8px;
        flex-shrink: 0;
        flex-wrap: wrap;
        align-items: center;
      }
      #toolbar button, #toolbar select {
        padding: 6px 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
        font-size: 0.9em;
      }
      #toolbar button:hover:not(:disabled), #toolbar select:hover:not(:disabled) {
        background: #f0f0f0;
        border-color: #999;
      }
      #toolbar button:disabled, #toolbar select:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #toolbar button svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
        margin-right: 6px;
        vertical-align: middle;
      }
      #toolbar input[type="text"], #toolbar input[type="password"] {
        padding: 6px 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 0.9em;
      }
      #toolbar .separator {
        border-left: 1px solid #ddd;
        height: 24px;
        margin: 0 8px;
      }
      #vendor-controls.is-ready {
        opacity: 0.45;
      }
      #vendor-controls.is-ready #upload-vendor-btn {
        opacity: 0.6;
      }
      #vendor-controls.is-ready #clear-vendor-btn {
        opacity: 0.85;
      }
      #vendor-controls.is-ready #vendor-status {
        font-weight: 600;
      }
      .mode-section {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .mode-section.hidden {
        display: none;
      }
      #mode-tabs {
        display: flex;
        gap: 0;
        margin-right: 8px;
      }
      #mode-tabs button {
        border-radius: 0;
        margin: 0;
      }
      #mode-tabs button:first-child {
        border-radius: 4px 0 0 4px;
      }
      #mode-tabs button:last-child {
        border-radius: 0 4px 4px 0;
        margin-left: -1px;
      }
      #mode-tabs button.active {
        background: #4a90d9;
        color: #fff;
        border-color: #4a90d9;
      }
      #server-config {
        background: #f0f7ff;
        border-bottom: 1px solid #d0e0f0;
        padding: 12px 16px;
        display: none;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      #server-config.visible {
        display: flex;
      }
      #server-config label {
        font-size: 0.85em;
        color: #555;
      }
      #server-config input[type="text"], #server-config input[type="password"] {
        padding: 6px 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 0.9em;
      }
      #server-config select {
        padding: 6px 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 0.9em;
        background: #fff;
      }
      #server-url {
        width: 300px;
      }
      #oauth-token {
        width: 250px;
      }
      #basic-username, #basic-password {
        width: 120px;
      }
      .auth-section {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .auth-section.hidden {
        display: none;
      }
      #form-list {
        min-width: 200px;
      }
      #form-container {
        flex: 1;
        overflow: auto;
        padding: 16px;
        background: #fff;
      }
      form-renderer {
        display: block;
        width: 100%;
        min-height: 100%;
      }
      #loading {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 200px;
        color: #666;
      }
      #error-message {
        padding: 20px;
        margin: 20px;
        background: #fee;
        border: 1px solid #c00;
        border-radius: 4px;
        color: #800;
        display: none;
      }
      /* Hide form-renderer until loaded */
      form-renderer:not(.loaded) {
        visibility: hidden;
        height: 0;
      }
    </style>
  </head>
  <body>
    <div id="header">
      <h1>Form Viewer</h1>
      <span id="form-name">No form loaded</span>
      <span id="sync-indicator" class="sync-off">‚è∏ Sync: OFF</span>
      <span id="status">Ready</span>
    </div>
    
    <!-- Server Configuration Panel (shown in server mode) -->
    <div id="server-config">
      <label>CDR Server:</label>
      <input type="text" id="server-url" placeholder="https://your-cdr.example.com/rest/v1" value="">
      
      <label>Auth:</label>
      <select id="auth-type">
        <option value="oauth">OAuth Token</option>
        <option value="basic">Basic Auth</option>
      </select>
      
      <div id="oauth-auth" class="auth-section">
        <input type="password" id="oauth-token" placeholder="Bearer token...">
      </div>
      
      <div id="basic-auth" class="auth-section hidden">
        <input type="text" id="basic-username" placeholder="Username">
        <input type="password" id="basic-password" placeholder="Password">
      </div>
      
      <button id="connect-btn">üîå Connect</button>
      <span class="separator"></span>
      
      <label>Form:</label>
      <select id="form-list" disabled>
        <option value="">-- Connect to load forms --</option>
      </select>
      <button id="load-server-form-btn" disabled title="Load selected form from server">
        <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
          <path d="M18 15v3H6v-3H4v3c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-3zm-1-4-1.41-1.41L13 12.17V4h-2v8.17L8.41 9.59 7 11l5 5z"></path>
        </svg>
        Load Form
      </button>
    </div>
    
    <div id="toolbar">
      <!-- Mode Tabs -->
      <div id="mode-tabs">
        <button id="local-mode-btn" class="active" title="Load forms from local files">üìÅ Local</button>
        <button id="server-mode-btn" title="Connect to a Better CDR server">üåê Server</button>
      </div>
      
      <!-- Local Mode Controls -->
      <div id="local-controls" class="mode-section">
        <input type="file" id="form-package-input" accept=".zip,.json" style="display: none;">
        <button id="load-form-btn" title="Load Better Studio form package (.zip or .json)">
          <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
            <path d="M18 15v3H6v-3H4v3c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-3zM7 9l1.41 1.41L11 7.83V16h2V7.83l2.59 2.58L17 9l-5-5z"></path>
          </svg>
          Load Form
        </button>
      </div>
      
      
      <span class="separator"></span>
      
      <!-- Common Controls -->
      <button id="get-data-btn" disabled title="Copy form data to clipboard as JSON">
        <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
          <path d="M9 4h9v12H9z" opacity=".3"></path>
          <path d="M18 2H9c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2m0 14H9V4h9zM3 15v-2h2v2zm0-5.5h2v2H3zM10 20h2v2h-2zm-7-1.5v-2h2v2zM5 22c-1.1 0-2-.9-2-2h2zm3.5 0h-2v-2h2zm5 0v-2h2c0 1.1-.9 2-2 2M5 6v2H3c0-1.1.9-2 2-2"></path>
        </svg>
        Copy values
      </button>
      <button id="clear-btn" disabled title="Clear form values">
        <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
          <path d="M16 9H8v10h8zm-.47 7.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12 1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14z" opacity=".3"></path>
          <path d="M14.12 10.47 12 12.59l-2.13-2.12-1.41 1.41L10.59 14l-2.12 2.12 1.41 1.41L12 15.41l2.12 2.12 1.41-1.41L13.41 14l2.12-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4zM6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM8 9h8v10H8z"></path>
        </svg>
        Clear form
      </button>

      <span class="separator"></span>
      
      <!-- Vendor Library Upload (for offline use) -->
      <div id="vendor-controls">
        Initial setup: 
        <input type="file" id="vendor-upload-input" accept=".js,.css" multiple style="display: none;">
        <button id="upload-vendor-btn" title="Upload Better Form Renderer library files (form-renderer.js, styles.css, styles-theme.css)">
          <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
            <path d="M18 15v3H6v-3H4v3c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-3zM7 9l1.41 1.41L11 7.83V16h2V7.83l2.59 2.58L17 9l-5-5z"></path>
          </svg>
          Upload Renderer
        </button>
        <button id="clear-vendor-btn" title="Clear cached renderer library">
          <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
            <path d="M16 9H8v10h8zm-.47 7.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12 1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14z" opacity=".3"></path>
            <path d="M14.12 10.47 12 12.59l-2.13-2.12-1.41 1.41L10.59 14l-2.12 2.12 1.41 1.41L12 15.41l2.12 2.12 1.41-1.41L13.41 14l2.12-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4zM6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM8 9h8v10H8z"></path>
          </svg>
          Clear Renderer
        </button>
        <span id="vendor-status" style="font-size: 0.8em; color: #666;"></span>
      </div>

    </div>
    
    <div id="form-container">
      <div id="loading">Select a mode and load a form to begin...</div>
      <div id="error-message"></div>
      <form-renderer id="form-renderer"></form-renderer>
    </div>

    <script>
      const formRenderer = document.getElementById('form-renderer');
      const formNameEl = document.getElementById('form-name');
      const statusEl = document.getElementById('status');
      const loadingEl = document.getElementById('loading');
      const errorEl = document.getElementById('error-message');
      const getDataBtn = document.getElementById('get-data-btn');
      const clearBtn = document.getElementById('clear-btn');
      const rawSearch = window.location.search || (window.location.hash ? `?${window.location.hash.replace(/^#/, '')}` : '');
      const urlParams = new URLSearchParams(rawSearch);
      const testModeEnabled = urlParams.get('testMode') === '1';
      const testModeAutoLoad = urlParams.get('autoLoad') !== '0';
      window.__formViewerBooted = true;
      window.__formViewerSearch = rawSearch;
      window.__formViewerTestMode = testModeEnabled;
      if (testModeEnabled && !window.formTestApi) {
        window.formTestApi = {
          isReady: () => false
        };
      }

      // Mode switching elements
      const localModeBtn = document.getElementById('local-mode-btn');
      const serverModeBtn = document.getElementById('server-mode-btn');
      const localControls = document.getElementById('local-controls');
      const serverConfig = document.getElementById('server-config');
      
      // Server mode elements
      const serverUrlInput = document.getElementById('server-url');
      const authTypeSelect = document.getElementById('auth-type');
      const oauthAuthSection = document.getElementById('oauth-auth');
      const basicAuthSection = document.getElementById('basic-auth');
      const oauthTokenInput = document.getElementById('oauth-token');
      const basicUsernameInput = document.getElementById('basic-username');
      const basicPasswordInput = document.getElementById('basic-password');
      const connectBtn = document.getElementById('connect-btn');
      const formListSelect = document.getElementById('form-list');
      const loadServerFormBtn = document.getElementById('load-server-form-btn');
      
      // Local mode elements
      let formLoaded = false;
      let currentFormData = null;
      let parentWindow = window.opener;
      let serviceWorkerReady = false;
      let swRegistration = null;
      let currentMode = 'local'; // 'local' or 'server'
      let serverConnected = false;
      let serverForms = []; // List of forms from server
      let syncModeEnabled = false; // Phase 4: Sync mode tracking

      // Register Service Worker for mock CDR
      async function registerMockCDR() {
        if ('serviceWorker' in navigator) {
          try {
            // Register service worker with appropriate scope for GitHub Pages
            // Use relative path so it works both locally and on GitHub Pages
            const scope = window.location.pathname.replace(/\/[^/]*$/, '/') || '/';
            swRegistration = await navigator.serviceWorker.register('form-mock-sw.js', { scope: scope });
            console.log('[Popup] Service Worker registered:', swRegistration.scope);
            
            // Wait for SW to be ready
            await navigator.serviceWorker.ready;
            
            // Ensure there's an active controller
            // If this is first load, SW won't control until reload
            if (!navigator.serviceWorker.controller) {
              console.log('[Popup] Service Worker registered but not controlling yet - requesting reload control');
              // Ask SW to take control immediately
              if (swRegistration.active) {
                swRegistration.active.postMessage({ type: 'CLAIM_CLIENTS' });
              }
              // Wait a bit for claim to take effect
              await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            serviceWorkerReady = !!navigator.serviceWorker.controller;
            console.log('[Popup] Service Worker ready:', serviceWorkerReady, 'controller:', !!navigator.serviceWorker.controller);
            
            // Listen for messages from SW
            navigator.serviceWorker.addEventListener('message', (event) => {
              if (event.data.type === 'FORM_CACHED') {
                console.log('[Popup] SW confirmed form cached:', event.data.formName);
                // Resolve any pending promise
                if (window._formCachedResolve) {
                  window._formCachedResolve(event.data.formName);
                  window._formCachedResolve = null;
                }
              }
            });
            
            return serviceWorkerReady;
          } catch (error) {
            console.error('[Popup] Service Worker registration failed:', error);
            return false;
          }
        } else {
          console.warn('[Popup] Service Workers not supported');
          return false;
        }
      }
      
      // Initialize SW and then load vendor files
      async function initializeApp() {
        const swReady = await registerMockCDR();
        console.log('[Popup] SW registration complete, ready:', swReady);

        if (testModeEnabled) {
          ensureTestModeBadge();
          installFormTestApi();
        }
        
        // Try to load vendor files (from cache via SW or from disk in dev)
        const rendererLoaded = await loadVendorFiles();
        console.log('[Popup] Vendor files load result:', rendererLoaded);
        
        // Initialize renderer if available
        initializeFormRenderer();

        if (testModeEnabled && testModeAutoLoad) {
          autoLoadDefaultFormPackages();
        }
        
        // Check vendor cache status
        if (swReady) {
          checkVendorCache();
        }
      }
      
      // Start initialization
      initializeApp();

      // ============================================================
      // MODE SWITCHING
      // ============================================================
      
      function switchToLocalMode() {
        currentMode = 'local';
        localModeBtn.classList.add('active');
        serverModeBtn.classList.remove('active');
        localControls.classList.remove('hidden');
        serverConfig.classList.remove('visible');
        
        // Reset renderer to use local mock CDR
        if (isFormRendererAvailable) {
          formRenderer.ehrServerUrl = window.location.origin + '/mock-cdr';
          formRenderer.credentials = { username: 'offline', password: 'offline' };
        }
        console.log('[Popup] Switched to Local mode');
      }
      
      function switchToServerMode() {
        currentMode = 'server';
        serverModeBtn.classList.add('active');
        localModeBtn.classList.remove('active');
        localControls.classList.add('hidden');
        serverConfig.classList.add('visible');
        console.log('[Popup] Switched to Server mode');
      }
      
      localModeBtn.addEventListener('click', switchToLocalMode);
      serverModeBtn.addEventListener('click', switchToServerMode);
      
      // ============================================================
      // AUTH TYPE SWITCHING
      // ============================================================
      
      authTypeSelect.addEventListener('change', () => {
        if (authTypeSelect.value === 'oauth') {
          oauthAuthSection.classList.remove('hidden');
          basicAuthSection.classList.add('hidden');
        } else {
          oauthAuthSection.classList.add('hidden');
          basicAuthSection.classList.remove('hidden');
        }
      });
      
      // ============================================================
      // SERVER CONNECTION
      // ============================================================
      
      async function connectToServer() {
        const serverUrl = serverUrlInput.value.trim();
        if (!serverUrl) {
          showError('Please enter a CDR server URL');
          return;
        }
        
        setStatus('Connecting...', '');
        connectBtn.disabled = true;
        
        try {
          // Build credentials based on auth type
          let credentials;
          if (authTypeSelect.value === 'oauth') {
            const token = oauthTokenInput.value.trim();
            if (!token) {
              throw new Error('Please enter an OAuth token');
            }
            credentials = { authType: 'oauth2', token: token };
          } else {
            const username = basicUsernameInput.value.trim();
            const password = basicPasswordInput.value.trim();
            if (!username || !password) {
              throw new Error('Please enter username and password');
            }
            credentials = { username, password };
          }
          
          // Configure renderer with server settings
          formRenderer.ehrServerUrl = serverUrl;
          formRenderer.credentials = credentials;
          
          // Fetch list of forms from server
          const formsUrl = `${serverUrl}/form`;
          const headers = buildAuthHeaders(credentials);
          
          console.log('[Popup] Fetching forms from:', formsUrl);
          const response = await fetch(formsUrl, { headers });
          
          if (!response.ok) {
            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
          }
          
          serverForms = await response.json();
          console.log('[Popup] Received forms:', serverForms);
          
          // Populate form dropdown
          formListSelect.innerHTML = '<option value="">-- Select a form --</option>';
          
          // Handle both array and object responses
          const formArray = Array.isArray(serverForms) ? serverForms : (serverForms.forms || []);
          
          formArray.forEach(form => {
            const option = document.createElement('option');
            const formName = form.name || form.formId || form.id;
            const formVersion = form.version || form.latestVersion || '';
            option.value = JSON.stringify({ name: formName, version: formVersion });
            option.textContent = formVersion ? `${formName} (v${formVersion})` : formName;
            formListSelect.appendChild(option);
          });
          
          formListSelect.disabled = false;
          loadServerFormBtn.disabled = false;
          serverConnected = true;
          setStatus('Connected', 'success');
          
        } catch (error) {
          console.error('[Popup] Connection failed:', error);
          showError('Connection failed: ' + error.message);
          serverConnected = false;
        } finally {
          connectBtn.disabled = false;
        }
      }
      
      function buildAuthHeaders(credentials) {
        const headers = new Headers();
        headers.set('Accept', 'application/json');
        
        if (credentials.authType === 'oauth2') {
          headers.set('Authorization', `Bearer ${credentials.token}`);
        } else if (credentials.username && credentials.password) {
          const basic = btoa(`${credentials.username}:${credentials.password}`);
          headers.set('Authorization', `Basic ${basic}`);
        }
        
        return headers;
      }
      
      async function loadFormFromServer() {
        const selected = formListSelect.value;
        if (!selected) {
          showError('Please select a form');
          return;
        }
        
        const formInfo = JSON.parse(selected);
        console.log('[Popup] Loading form from server:', formInfo);
        
        setStatus('Loading form...', '');
        loadingEl.style.display = 'flex';
        loadingEl.textContent = 'Loading form from server...';
        errorEl.style.display = 'none';
        
        try {
          // Use formMetadata to let renderer fetch the form
          formRenderer.formMetadata = {
            name: formInfo.name,
            version: formInfo.version || undefined
          };
          
          formNameEl.textContent = `${formInfo.name}${formInfo.version ? ' v' + formInfo.version : ''}`;
          document.title = `Form: ${formInfo.name} - Kintegrate`;
          
        } catch (error) {
          console.error('[Popup] Error loading form from server:', error);
          showError('Failed to load form: ' + error.message);
        }
      }
      
      connectBtn.addEventListener('click', connectToServer);
      loadServerFormBtn.addEventListener('click', loadFormFromServer);
      
      function setStatus(message, type = '') {
        statusEl.textContent = message;
        statusEl.className = type;
      }

      function showError(message) {
        errorEl.textContent = message;
        errorEl.style.display = 'block';
        loadingEl.style.display = 'none';
        setStatus('Error', 'error');
      }
      
      function hideError() {
        errorEl.style.display = 'none';
      }

      function hideLoading() {
        loadingEl.style.display = 'none';
      }
      
      // Phase 4: Update sync indicator
      function updateSyncIndicator() {
        const statusText = syncModeEnabled ? 'üîÑ Sync: ON' : '‚è∏ Sync: OFF';
        const indicator = document.getElementById('sync-indicator');
        if (indicator) {
          indicator.textContent = statusText;
          indicator.className = syncModeEnabled ? 'sync-on' : 'sync-off';
        }
      }

      function ensureTestModeBadge() {
        if (!testModeEnabled) {
          return;
        }
        document.body.dataset.testMode = '1';
        const header = document.getElementById('header');
        if (!header || document.getElementById('test-mode-badge')) {
          return;
        }
        const badge = document.createElement('span');
        badge.id = 'test-mode-badge';
        badge.textContent = 'TEST MODE';
        header.appendChild(badge);
      }

      function buildFieldIndex(formDescription) {
        const index = {
          byPath: {},
          byTag: {},
          byId: {}
        };

        const visitNode = (node) => {
          if (!node || typeof node !== 'object') {
            return;
          }

          const path = node.aqlPath || node.path || node.aql_path || null;
          const tag = node.tag || node.alias || node.name || null;
          const id = node.id || node.formId || node.form_id || null;

          if (path) {
            index.byPath[path] = node;
          }
          if (tag) {
            index.byTag[tag] = node;
          }
          if (id) {
            index.byId[id] = node;
          }

          if (Array.isArray(node.children)) {
            node.children.forEach(visitNode);
          }
        };

        visitNode(formDescription);
        return index;
      }

      function installFormTestApi() {
        if (!testModeEnabled) {
          return;
        }

        const fieldIndex = currentFormData?.formDescription
          ? buildFieldIndex(currentFormData.formDescription)
          : { byPath: {}, byTag: {}, byId: {} };

        window.formTestApi = {
          isReady: () => !!formRenderer && formRenderer.classList.contains('loaded'),
          getFormInfo: () => formRenderer.getScriptApi?.()?.getFormInfo?.(),
          getFieldModel: (tagOrPath, searchWithinContainerTag, containerMultiIndex) =>
            formRenderer.getScriptApi?.()?.getFieldModel?.(tagOrPath, searchWithinContainerTag, containerMultiIndex),
          setFieldValue: (tagOrPath, value, multiIndex, searchWithinContainerTag, containerMultiIndex) =>
            formRenderer.getScriptApi?.()?.setFieldValue?.(tagOrPath, value, multiIndex, searchWithinContainerTag, containerMultiIndex),
          getFieldValue: (tagOrPath, multiIndex, searchWithinContainerTag, containerMultiIndex, simpleValue = true) =>
            formRenderer.getScriptApi?.()?.getFieldValue?.(tagOrPath, multiIndex, searchWithinContainerTag, containerMultiIndex, simpleValue),
          isHidden: (tagOrPath, searchWithinContainerTag, containerMultiIndex) =>
            formRenderer.getScriptApi?.()?.getFieldModel?.(tagOrPath, searchWithinContainerTag, containerMultiIndex)?.isHidden ?? null,
          getFieldIndex: () => fieldIndex,
          resolveTagFromPath: (path) => fieldIndex.byPath?.[path]?.tag || fieldIndex.byPath?.[path]?.alias || null
        };
      }

      // Track if form renderer is available (updated after dynamic load)
      let isFormRendererAvailable = false;

      // Dynamically load vendor files from cache via Service Worker
      async function loadVendorFiles() {
        console.log('[Popup] Attempting to load vendor files...');
        
        // Load CSS files
        const cssFiles = ['styles.css', 'styles-theme.css'];
        for (const file of cssFiles) {
          const link = document.createElement('link');
          link.rel = 'stylesheet';
          link.href = 'vendor/' + file;
          document.head.appendChild(link);
          console.log('[Popup] Added CSS link:', file);
        }
        
        // Load JS file and wait for it
        return new Promise((resolve) => {
          const script = document.createElement('script');
          script.src = 'vendor/form-renderer.js';
          script.onload = () => {
            console.log('[Popup] form-renderer.js loaded successfully');
            // Give custom element time to register
            setTimeout(() => {
              isFormRendererAvailable = customElements.get('form-renderer') !== undefined;
              console.log('[Popup] Form renderer available:', isFormRendererAvailable);
              resolve(isFormRendererAvailable);
            }, 100);
          };
          script.onerror = () => {
            console.log('[Popup] form-renderer.js failed to load');
            resolve(false);
          };
          document.head.appendChild(script);
        });
      }

      // Initialize form renderer after it's loaded
      function initializeFormRenderer() {
        if (!isFormRendererAvailable) {
          showError('Better Form Renderer is not available. Click "Upload Renderer" to upload the library files (requires license from Better Platform).');
          return;
        }
        
        hideError();
        
        // Initialize form renderer with mock CDR URL
        // The service worker will intercept requests to /mock-cdr/
        formRenderer.ehrServerUrl = window.location.origin + '/mock-cdr';
        formRenderer.credentials = { username: 'offline', password: 'offline' };
        formRenderer.context = {
          language: 'sv',
          territory: 'SE',
          readonly: false,
          validationDisabled: true,
          formDataFormat: 'FLAT'
        };

        ensureTestModeBadge();
        installFormTestApi();

        // Event handlers - use addEventListener as per Better docs for framework-agnostic JS
        formRenderer.addEventListener('onFormRendered', (event) => {
          formLoaded = true;
          formRenderer.classList.add('loaded');
          hideLoading();
          setStatus('Form loaded', 'success');
          getDataBtn.disabled = false;
          clearBtn.disabled = false;
          console.log('Form rendered successfully');
          installFormTestApi();
        });

        formRenderer.addEventListener('onValueChange', (event) => {
          console.log('onValueChange event:', event?.detail);
          
          // Phase 4: Send composition to parent if sync mode is enabled
          if (syncModeEnabled && parentWindow) {
            try {
              const composition = formRenderer.composition;
              parentWindow.postMessage({
                type: 'COMPOSITION_CHANGED',
                payload: { composition }
              }, window.location.origin);
              console.log('[Popup] Sent COMPOSITION_CHANGED to parent');
            } catch (error) {
              console.error('[Popup] Error sending composition change:', error);
            }
          }
        });

        formRenderer.addEventListener('onFormError', (event) => {
          const error = event?.detail;
          console.error('[Popup] Form error object:', error);
          console.error('[Popup] Form error details:', JSON.stringify(error, Object.getOwnPropertyNames(error || {}), 2));
          const errorMsg = error?.message || error?.error || error?.detail || 'Unknown error (check console)';
          showError('Form error: ' + errorMsg);
        });
        
        console.log('[Popup] Form renderer initialized');
      }

      // Load form from message
      function loadForm(formData) {
        if (!isFormRendererAvailable) {
          showError('Form Renderer not available');
          return;
        }

        try {
          currentFormData = formData;
          // Extract name from various sources
          const formName = formData.name || 
                          formData.manifest?.resource?.name || 
                          'Unnamed form';
          formNameEl.textContent = formName;
          document.title = `Form: ${formName} - Kintegrate`;
          setStatus('Loading...', '');

          // Notify parent that we're loading
          if (parentWindow) {
            parentWindow.postMessage({ type: 'formLoaded', formName: formName }, '*');
          }

          // Set form environment if available
          if (formData.formEnvironment) {
            formRenderer.formEnvironment = formData.formEnvironment;
          }

          // Load the form definition
          if (formData.formDescription) {
            console.log('Loading form:', formName, formData.formDescription);
            
            // Use requestAnimationFrame to ensure proper initialization
            requestAnimationFrame(() => {
              formRenderer.webTemplate = formData.formDescription;
            });
          } else {
            showError('No form description provided');
          }
        } catch (error) {
          showError('Error loading form: ' + error.message);
          console.error('Load error:', error);
          if (parentWindow) {
            parentWindow.postMessage({ type: 'formError', error: error.message }, '*');
          }
        }
      }

      function resolveExampleFormUrl(fileName) {
        const basePath = window.location.pathname.replace(/\/[^/]*$/, '/') || '/';
        return new URL(`${basePath}example/forms/${fileName}`, window.location.origin).toString();
      }

      async function loadFormPackageZipFromUrl(fileName) {
        const url = resolveExampleFormUrl(fileName);
        console.log('[Popup] Attempting to load default form package:', url);

        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to fetch form package: ${response.status}`);
        }

        const blob = await response.blob();
        const file = new File([blob], fileName, { type: 'application/zip' });
        await loadFormPackageZip(file);
      }

      async function autoLoadDefaultFormPackages() {
        if (currentMode !== 'local') {
          switchToLocalMode();
        }

        const candidates = [
          '24oktDemo_1_0_4_FORM.zip',
          'MDK_Rek_demo_1_0_131_FORM.zip'
        ];

        for (const fileName of candidates) {
          try {
            setStatus('Loading default form...', '');
            loadingEl.style.display = 'flex';
            loadingEl.textContent = `Loading ${fileName}...`;
            await loadFormPackageZipFromUrl(fileName);
            console.log('[Popup] Default form loaded:', fileName);
            return;
          } catch (error) {
            console.warn('[Popup] Default form load failed:', fileName, error.message);
          }
        }

        showError('Unable to auto-load default form packages. Please load a form manually.');
      }

      // Listen for messages from parent window
      window.addEventListener('message', (event) => {
        // Basic origin check - in production you'd want stricter validation
        if (!event.data?.type) return;
        
        console.log('[Popup] Received message:', event.data.type);

        switch (event.data.type) {
          // === New Protocol Messages ===
          case 'PONG':
            console.log('[Popup] Received PONG from parent:', event.data.payload);
            setStatus('Connected to Kintegrate', 'success');
            setTimeout(() => setStatus(formLoaded ? 'Form loaded' : 'Ready'), 1500);
            break;
            
          case 'SYNC_MODE_STATUS':
            syncModeEnabled = event.data.payload?.enabled || false;
            console.log('[Popup] Sync mode:', syncModeEnabled ? 'ON' : 'OFF');
            // Update visual indicator
            updateSyncIndicator();
            break;
            
          case 'REQUEST_COMPOSITION':
            // Parent is requesting composition data (manual pull)
            if (parentWindow) {
              try {
                const composition = formRenderer.composition;
                if (composition) {
                  parentWindow.postMessage({
                    type: 'COMPOSITION_DATA',
                    payload: { composition }
                  }, window.location.origin);
                  console.log('[Popup] Sent COMPOSITION_DATA to parent');
                  setStatus('Data sent', 'success');
                  setTimeout(() => setStatus(formLoaded ? 'Form loaded' : 'Ready'), 1500);
                } else {
                  console.log('[Popup] No composition data available to send');
                  setStatus('No data to send', 'error');
                  setTimeout(() => setStatus(formLoaded ? 'Form loaded' : 'Ready'), 1500);
                }
              } catch (error) {
                console.error('[Popup] Error getting composition:', error);
                parentWindow.postMessage({
                  type: 'COMPOSITION_DATA',
                  payload: { composition: null, error: error.message }
                }, window.location.origin);
              }
            }
            break;
            
          case 'LOAD_COMPOSITION':
            // Parent is pushing composition data to form
            if (isFormRendererAvailable && event.data.payload?.composition) {
              console.log('[Popup] Loading composition from parent');
              try {
                formRenderer.composition = event.data.payload.composition;
                console.log('[Popup] Composition set on form renderer:', formRenderer.composition ? 'OK' : 'null');
                setStatus('Composition loaded', 'success');
              } catch (error) {
                console.error('[Popup] Error loading composition:', error);
                setStatus('Error loading composition', 'error');
              }
            } else {
              console.log('[Popup] Cannot load composition - renderer available:', isFormRendererAvailable, 
                          'composition provided:', !!event.data.payload?.composition);
            }
            break;

          // === Legacy Protocol Messages (keep for compatibility) ===
          case 'loadForm':
            if (event.data.formData) {
              console.log('Received form data from parent');
              // Merge formData properties with optional top-level name
              const formDataWithName = {
                ...event.data.formData,
                name: event.data.formName || event.data.formData.manifest?.resource?.name || 'Unnamed form'
              };
              loadForm(formDataWithName);
            }
            break;
          
          case 'getComposition':
            // Parent is requesting the composition data
            if (formLoaded && parentWindow) {
              try {
                const composition = formRenderer.composition;
                parentWindow.postMessage({
                  type: 'formComposition',
                  composition: composition
                }, '*');
                setStatus('Data sent', 'success');
                setTimeout(() => setStatus('Form loaded', 'success'), 1500);
              } catch (error) {
                console.error('Error getting composition:', error);
                parentWindow.postMessage({
                  type: 'formError',
                  error: 'Failed to get composition: ' + error.message
                }, '*');
              }
            }
            break;
        }
      });

      // Button handlers
      getDataBtn.addEventListener('click', () => {
        if (!formLoaded) return;
        try {
          const composition = formRenderer.composition;
          if (composition) {
            const json = JSON.stringify(composition, null, 2);
            navigator.clipboard.writeText(json).then(() => {
              setStatus('Copied to clipboard!', 'success');
              setTimeout(() => setStatus('Form loaded', 'success'), 2000);
            }).catch(() => {
              // Fallback: show in console
              console.log('Composition:', json);
              setStatus('Data logged to console', '');
            });
          } else {
            setStatus('No data in form', '');
          }
        } catch (error) {
          console.error('Error getting composition:', error);
          setStatus('Error getting data', 'error');
        }
      });

      clearBtn.addEventListener('click', () => {
        if (!formLoaded) return;
        try {
          // Try to get ScriptApi for clearing
          const api = formRenderer.getScriptApi?.();
          if (api?.clearValues) {
            api.clearValues();
            setStatus('Form cleared', 'success');
          } else {
            // Fallback: reload the form
            formRenderer.composition = null;
            setStatus('Form reset', 'success');
          }
        } catch (error) {
          console.error('Error clearing form:', error);
        }
      });

      // ============================================
      // Phase 3: Form Package Loading
      // ============================================
      
      const loadFormBtn = document.getElementById('load-form-btn');
      const formPackageInput = document.getElementById('form-package-input');
      
      loadFormBtn?.addEventListener('click', () => {
        formPackageInput?.click();
      });
      
      formPackageInput?.addEventListener('change', async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        
        try {
          setStatus('Loading form package...', '');
          loadingEl.style.display = 'flex';
          loadingEl.textContent = 'Loading form package...';
          
          if (file.name.endsWith('.zip')) {
            await loadFormPackageZip(file);
          } else if (file.name.endsWith('.json')) {
            await loadFormPackageJson(file);
          } else {
            throw new Error('Unsupported file type. Please use .zip or .json');
          }
        } catch (err) {
          console.error('[Popup] Error loading form package:', err);
          showError('Failed to load: ' + err.message);
        }
        
        // Reset file input so same file can be loaded again
        formPackageInput.value = '';
      });
      
      async function loadFormPackageZip(file) {
        console.log('[Popup] Loading ZIP file:', file.name);
        
        const arrayBuffer = await file.arrayBuffer();
        const outerZip = await JSZip.loadAsync(arrayBuffer);
        
        console.log('[Popup] Outer ZIP contents:', Object.keys(outerZip.files));
        
        // Better Studio package structure:
        // - Outer ZIP: package-manifest.json (package index) + inner form ZIP + optional .opt template
        // - Inner ZIP: manifest.json (form metadata) + form-description + other resources
        
        // Find inner ZIP (the actual form package)
        let innerZip = null;
        let innerZipName = null;
        for (const filename of Object.keys(outerZip.files)) {
          if (filename.endsWith('.zip') && !outerZip.files[filename].dir) {
            innerZipName = filename;
            console.log('[Popup] Found inner ZIP:', filename);
            break;
          }
        }
        
        // Read package-manifest.json from outer ZIP (package index)
        const packageManifestFile = outerZip.file('package-manifest.json');
        let packageManifest = null;
        if (packageManifestFile) {
          packageManifest = JSON.parse(await packageManifestFile.async('text'));
          console.log('[Popup] Package manifest:', packageManifest);
        }
        
        // Load the inner ZIP which contains the actual form
        if (innerZipName) {
          const innerData = await outerZip.files[innerZipName].async('arraybuffer');
          innerZip = await JSZip.loadAsync(innerData);
          console.log('[Popup] Inner ZIP contents:', Object.keys(innerZip.files));
        }
        
        // The form ZIP (inner or outer if no nesting) should have manifest.json
        const formZip = innerZip || outerZip;
        const formManifestFile = formZip.file('manifest.json');
        
        if (!formManifestFile) {
          throw new Error('No manifest.json found in form package');
        }
        
        const formManifest = JSON.parse(await formManifestFile.async('text'));
        console.log('[Popup] Form manifest:', formManifest);
        
        // Read all form resource files and bundle them
        const formBundle = {
          manifest: formManifest
        };
        
        // List of expected resource files in a form package
        const resourceFiles = [
          'form-description',
          'form-environment', 
          'form-layout',
          'form-metadata',
          'app-pages',
          'summary-pages',
          'templates',
          'widget-configuration'
        ];
        
        for (const resourceName of resourceFiles) {
          const resourceFile = formZip.file(resourceName);
          if (resourceFile) {
            try {
              const content = await resourceFile.async('text');
              formBundle[resourceName] = JSON.parse(content);
            } catch (e) {
              // Some files might not be valid JSON (e.g., templates)
              formBundle[resourceName] = await resourceFile.async('text');
            }
          }
        }
        
        console.log('[Popup] Form bundle assembled with resources:', Object.keys(formBundle));
        
        // Extract form name/version from form manifest
        const formName = formManifest.resource?.name || formManifest.name || file.name.replace('.zip', '');
        const formVersion = formManifest.resource?.version || formManifest.version || '1.0.0';
        const templateId = formManifest.resource?.templateId;
        
        // Load into renderer
        loadFormDefinitionIntoRenderer(formBundle, { name: formName, version: formVersion, templateId });
      }
      
      async function loadFormPackageJson(file) {
        console.log('[Popup] Loading JSON file:', file.name);
        
        const text = await file.text();
        const formDefinition = JSON.parse(text);
        
        // Extract form name from definition or filename
        const formName = formDefinition.templateId || file.name.replace('.json', '');
        
        loadFormDefinitionIntoRenderer(formDefinition, { name: formName, version: '1.0.0' });
      }
      
      async function loadFormDefinitionIntoRenderer(formBundle, manifest) {
        console.log('[Popup] Loading form definition into renderer:', manifest.name);
        
        if (!isFormRendererAvailable) {
          showError('Form Renderer not available');
          return;
        }
        
        try {
          // Update UI
          formNameEl.textContent = `${manifest.name} v${manifest.version}`;
          document.title = `Form: ${manifest.name} - Kintegrate`;
          setStatus('Rendering form...', '');
          
          // Get the form-description (the actual form definition)
          let formDescription;
          let formEnvironment = null;
          let templates = null;
          let formLayout = null;
          
          if (formBundle['form-description']) {
            formDescription = formBundle['form-description'];
            formEnvironment = formBundle['form-environment'] || null;
            templates = formBundle['templates'] || null;
            formLayout = formBundle['form-layout'] || null;
          } else {
            // Direct JSON (already the form definition)
            formDescription = formBundle;
          }
          
          // Parse templates if it's a string (JSON array)
          if (typeof templates === 'string') {
            try {
              templates = JSON.parse(templates);
            } catch (e) {
              console.warn('[Popup] Could not parse templates:', e);
              templates = [];
            }
          }
          
          console.log('[Popup] Form description structure:', {
            id: formDescription?.id || formDescription?.formId,
            hasChildren: !!formDescription?.children,
            childrenCount: formDescription?.children?.length,
            topLevelKeys: Object.keys(formDescription || {}).slice(0, 10)
          });
          console.log('[Popup] TemplateId:', manifest.templateId);
          console.log('[Popup] Templates:', templates);
          
          // IMPORTANT: The renderer's webTemplate setter actually expects form-description format!
          // From analyzing form-renderer.js:
          //   set webTemplate(e) {
          //     Array.isArray(i) ‚Üí this.formDescription = i
          //     i?.children?.length ‚Üí this.formDescription = i.children  
          //     i?.webTemplate?.tree?.children ‚Üí this.formDescription = i.webTemplate.tree.children
          //   }
          // So webTemplate setter converts input to formDescription internally.
          
          // Set formEnvironment first if available
          if (formEnvironment) {
            console.log('[Popup] Setting formEnvironment:', Object.keys(formEnvironment));
            formRenderer.formEnvironment = formEnvironment;
          }
          
          // First, cache the form in Service Worker so CDR fetch returns our data
          if (serviceWorkerReady && navigator.serviceWorker.controller) {
            console.log('[Popup] Caching form in Service Worker before triggering load...');
            
            // Create a promise to wait for SW to confirm caching
            const cachePromise = new Promise((resolve, reject) => {
              window._formCachedResolve = resolve;
              setTimeout(() => {
                if (window._formCachedResolve) {
                  window._formCachedResolve = null;
                  reject(new Error('SW cache timeout'));
                }
              }, 2000);
            });
            
            // Send form data to the service worker to cache
            navigator.serviceWorker.controller.postMessage({
              type: 'CACHE_FORM',
              formDescription: formDescription,
              formEnvironment: formEnvironment,
              formName: manifest.name,
              formVersion: manifest.version,
              templates: templates,
              formLayout: formLayout,
              templateId: manifest.templateId
            });
            
            try {
              await cachePromise;
              console.log('[Popup] SW confirmed form cached');
            } catch (swErr) {
              console.warn('[Popup] SW cache warning:', swErr.message);
            }
          }
          
          // Now trigger the renderer's internal flow
          // IMPORTANT: Do NOT set webTemplate - it extracts children and breaks parsing
          // Instead, just set formMetadata and let the renderer fetch from CDR (mocked by SW)
          console.log('[Popup] Setting formMetadata to trigger renderer initialization...');
          
          // Create form metadata object
          const formMeta = {
            name: manifest.name,
            version: manifest.version,
            templateId: manifest.templateId
          };
          console.log('[Popup] Form metadata:', formMeta);
          
          try {
            // Just set formMetadata - the renderer will fetch from CDR
            // The Service Worker will intercept the request and return our cached form data
            console.log('[Popup] Setting formMetadata (SW will intercept CDR fetch)...');
            formRenderer.formMetadata = formMeta;
            
            console.log('[Popup] formMetadata set, waiting for renderer to fetch from mock CDR...');
          } catch (metaError) {
            console.error('[Popup] Error setting formMetadata:', metaError);
          }
          
          // NOTE: Service Worker approach disabled - using direct webTemplate property instead
          // The webTemplate setter in form-renderer.js handles form-description format directly
          
          // Fallback: if onFormRendered doesn't fire, check after a delay
          setTimeout(() => {
            if (!formLoaded) {
              console.log('[Popup] onFormRendered not fired after 3s, checking form state...');
              // Check if form has rendered content
              const hasContent = formRenderer.shadowRoot?.querySelector('form') || 
                                 formRenderer.querySelector('form') ||
                                 formRenderer.innerHTML.length > 100;
              console.log('[Popup] Form has content:', hasContent, 'innerHTML length:', formRenderer.innerHTML?.length);
              
              if (hasContent || formRenderer.innerHTML?.length > 100) {
                formLoaded = true;
                formRenderer.classList.add('loaded');
                hideLoading();
                setStatus('Form loaded (fallback)', 'success');
                getDataBtn.disabled = false;
                clearBtn.disabled = false;
                console.log('[Popup] Form loaded via fallback detection');
              } else {
                console.log('[Popup] Form content not detected - check console for errors');
                setStatus('Form may not have loaded', 'error');
              }
            }
          }, 3000);
          
        } catch (error) {
          console.error('[Popup] Error loading form:', error);
          showError('Error loading form: ' + error.message);
        }
      }

      // ============================================
      // Vendor Library Upload Handlers
      // ============================================
      
      const uploadVendorBtn = document.getElementById('upload-vendor-btn');
      const vendorUploadInput = document.getElementById('vendor-upload-input');
      const clearVendorBtn = document.getElementById('clear-vendor-btn');
      const vendorStatus = document.getElementById('vendor-status');

      function setVendorControlsReady(isReady) {
        const vendorControls = document.getElementById('vendor-controls');
        if (!vendorControls) return;
        vendorControls.classList.toggle('is-ready', isReady);
      }
      
      // Check for cached vendor files on load
      async function checkVendorCache() {
        if (!navigator.serviceWorker.controller) {
          vendorStatus.textContent = 'Initializing...';
          return;
        }
        
        navigator.serviceWorker.controller.postMessage({ type: 'GET_VENDOR_FILES' });
        
        // Wait for response
        const response = await new Promise((resolve) => {
          const handler = (event) => {
            if (event.data.type === 'VENDOR_FILES_LIST') {
              navigator.serviceWorker.removeEventListener('message', handler);
              resolve(event.data.files);
            }
          };
          navigator.serviceWorker.addEventListener('message', handler);
          
          // Timeout after 2 seconds
          setTimeout(() => {
            navigator.serviceWorker.removeEventListener('message', handler);
            resolve([]);
          }, 2000);
        });
        
        const hasCached = response && response.length > 0;
        const hasRenderer = hasCached || isFormRendererAvailable;

        if (hasCached) {
          vendorStatus.textContent = `‚úÖ ${response.length} file${response.length > 1 ? 's' : ''} cached`;
          vendorStatus.style.color = '#080';
        } else if (isFormRendererAvailable) {
          vendorStatus.textContent = '‚úÖ Renderer available (local)';
          vendorStatus.style.color = '#080';
        } else {
          vendorStatus.textContent = 'No renderer cached';
          vendorStatus.style.color = '#666';
        }

        setVendorControlsReady(hasRenderer);
      }
      
      uploadVendorBtn?.addEventListener('click', () => {
        vendorUploadInput?.click();
      });
      
      vendorUploadInput?.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;
        
        if (!navigator.serviceWorker.controller) {
          alert('Service Worker is not active. Please reload the page and try again.');
          return;
        }
        
        try {
          vendorStatus.textContent = 'Uploading...';
          vendorStatus.style.color = '#666';
          
          let successCount = 0;
          let errorCount = 0;
          
          // Get base path for GitHub Pages compatibility
          const basePath = window.location.pathname.replace(/\/[^/]*$/, '/') || '/';
          
          for (const file of files) {
            try {
              const content = await file.arrayBuffer();
              const contentType = file.type || getContentType(file.name);
              
              console.log(`[Popup] Caching vendor file: ${file.name} (${contentType}) at ${basePath}vendor/`);
              
              // Send to service worker with base path
              navigator.serviceWorker.controller.postMessage({
                type: 'CACHE_VENDOR_FILE',
                filename: file.name,
                content: content,
                contentType: contentType,
                basePath: basePath
              });
              
              // Wait for confirmation
              await new Promise((resolve, reject) => {
                const handler = (event) => {
                  if (event.data.type === 'VENDOR_FILE_CACHED' && event.data.filename === file.name) {
                    navigator.serviceWorker.removeEventListener('message', handler);
                    resolve();
                  } else if (event.data.type === 'VENDOR_FILE_CACHE_ERROR') {
                    navigator.serviceWorker.removeEventListener('message', handler);
                    reject(new Error(event.data.error));
                  }
                };
                navigator.serviceWorker.addEventListener('message', handler);
                
                // Timeout after 5 seconds
                setTimeout(() => {
                  navigator.serviceWorker.removeEventListener('message', handler);
                  resolve(); // Don't fail on timeout
                }, 5000);
              });
              
              successCount++;
            } catch (fileError) {
              console.error(`[Popup] Error uploading ${file.name}:`, fileError);
              errorCount++;
            }
          }
          
          if (errorCount === 0) {
            vendorStatus.textContent = `‚úÖ ${successCount} file${successCount > 1 ? 's' : ''} uploaded`;
            vendorStatus.style.color = '#080';
            setVendorControlsReady(true);
            alert(`Successfully uploaded ${successCount} file${successCount > 1 ? 's' : ''}.\n\nYou can now use the form renderer offline.\n\nNote: Reload this page for the renderer to load from cache.`);
          } else {
            vendorStatus.textContent = `‚ö† ${successCount} ok, ${errorCount} failed`;
            vendorStatus.style.color = '#c60';
            alert(`Uploaded ${successCount} file(s), but ${errorCount} failed.\nCheck console for details.`);
          }
          
          // Refresh cache status
          setTimeout(checkVendorCache, 500);
        } catch (err) {
          console.error('[Popup] Error uploading vendor files:', err);
          vendorStatus.textContent = '‚ùå Upload failed';
          vendorStatus.style.color = '#c00';
          alert('Upload failed: ' + err.message);
        }
        
        // Reset file input
        vendorUploadInput.value = '';
      });
      
      clearVendorBtn?.addEventListener('click', async () => {
        if (!confirm('Clear all cached vendor library files?\n\nYou will need to upload them again to use the form renderer offline.')) {
          return;
        }
        
        if (!navigator.serviceWorker.controller) {
          alert('Service Worker is not active.');
          return;
        }
        
        try {
          vendorStatus.textContent = 'Clearing...';
          vendorStatus.style.color = '#666';
          
          navigator.serviceWorker.controller.postMessage({ type: 'CLEAR_VENDOR_CACHE' });
          
          // Wait for confirmation
          await new Promise((resolve) => {
            const handler = (event) => {
              if (event.data.type === 'VENDOR_CACHE_CLEARED') {
                navigator.serviceWorker.removeEventListener('message', handler);
                resolve();
              }
            };
            navigator.serviceWorker.addEventListener('message', handler);
            
            setTimeout(() => {
              navigator.serviceWorker.removeEventListener('message', handler);
              resolve();
            }, 2000);
          });
          
          vendorStatus.textContent = 'Cache cleared';
          vendorStatus.style.color = '#666';
          setVendorControlsReady(false);
          
          alert('Vendor cache cleared.\n\nThe page will reload to use the network version (if available).');
          window.location.reload();
        } catch (err) {
          console.error('[Popup] Error clearing vendor cache:', err);
          vendorStatus.textContent = '‚ùå Clear failed';
          vendorStatus.style.color = '#c00';
        }
      });
      
      function getContentType(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        const types = {
          'js': 'application/javascript',
          'css': 'text/css',
          'json': 'application/json',
          'html': 'text/html'
        };
        return types[ext] || 'application/octet-stream';
      }
      
      // Check vendor cache on load
      setTimeout(checkVendorCache, 1000);

      // Notify parent that we're ready
      if (parentWindow) {
        parentWindow.postMessage({ type: 'FORM_VIEWER_READY', payload: {} }, window.location.origin);
        console.log('[Popup] Sent FORM_VIEWER_READY to parent');
        
        // Send a ping to test communication
        setTimeout(() => {
          parentWindow.postMessage({ type: 'REQUEST_PING', payload: {} }, window.location.origin);
          console.log('[Popup] Sent REQUEST_PING to test communication');
        }, 500);
      }

      // Handle window close
      window.addEventListener('beforeunload', () => {
        if (parentWindow) {
          parentWindow.postMessage({ type: 'FORM_VIEWER_CLOSED', payload: {} }, window.location.origin);
        }
      });
    </script>
  </body>
</html>
