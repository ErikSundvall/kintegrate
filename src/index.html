<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Kintegrate</title>
    <link rel="stylesheet" href="resizable-columns.css">
    <!--  css for tree widget -->
    <link rel="stylesheet" href="tree.min.css">
    <!-- CodeMirror 5 CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">


  </head>
  <body>
    <main>
      <div class="fullheight-container" id="main-container">
        <div id="input-container" class="column column-left">
            <!-- file picker that can pick files from user upload -->
            Pick example file <input type="file" id="fileInput" accept=".json,.xml,.txt"><br>
            or select example:
            <!-- Dropdown that can load any existing file in web server side subdirectory /example/instance into the textarea that has id="inputInstance"  -->
            <select id="exampleSelect">
              <option value="">--Select an example--</option>
              <option value="intro.json">intro.json</option>
              <option value="MDK_Rek_demo1.json">MDK_Rek_demo1.json</option>
              <option value="mdk_lunga_1.json">mdk_lunga_1.json</option>
              <option value="non_existing_example.json">non_existing_example.json</option>
            </select><br>
            or just paste input into the box below<br>
            <textarea id="inputInstance">Input example goes here</textarea>
            <hr>
            <div id="json-tree-container">Parsed input from above goes here into a foldable tree. The tree-branches can then be clicked to get paths that can be used in conversion template</div>
        </div>
        <div class="resizer"></div>
        <div id="conversion-container" class="column column-center">
            <h2>Conversion Template (Handlebars)</h2>
            <div id="selection-list">
              <div class="tree-actions">
                <div id="selected-paths">No nodes selected. Use checkboxes to select nodes.</div>
              </div>
            </div>
            <textarea id="template-editor">
{{!-- <--- This is how you start a comment block in Handlebars
  This is the column where you author (and possibly compile) your conversion script.
  Currently you see a simple Handlebars template.
  After importing instance data and/or schema (or other structure defitnitions) they can help you author the conversion script.
  Select nodes in the tree on the left to insert paths to data elements at the current cursor position in this template.
 This ends comment block:   --}}
 
If intro.json is loaded as source this example will work, otherwise likely a lot of blank spots:
----- Start -----
Remember, ⤡ means: {{starter_tips.tip_object.Right_click_explanations.[⤡]}}

A number of tips:
{{#with starter_tips}}
  {{#each tip_array}}
- {{.}}
  {{/each}}
{{/with}}
----- The end -----

{{!-- Another comment block. Remove this line to run it
  
The examples below fit with the example input file MDK_Rek_demo1.json

Example with full flat path: 
  {{granskning.bakgrund.0.sjukdomshistoria.0.ospecificerad_händelse.0.anamnes.0.[|value]}}

Example looping/traversing tree combined with parital flat 
paths when we have reached a relevant repeating level:
  {{#with granskning}}
    {{#each rubrik}}
      {{#each behållare}}
        {{#each deltagare}} {{! this is a list with potentially many rows }}
Närvarande:
          {{#each deltagare}} 
{{namn.0.[|value]}} (Specialitet: {{vårdgivarroll.0.specialitet.0.[|value]}})
          {{/each}}
        {{/each}}
      {{/each}}
    {{/each}}
  {{/with}}

Bakgrund:
{{#with granskning}}
  {{#each bakgrund}}
    {{#each sjukdomshistoria}}
      {{#each ospecificerad_händelse}}
 Aktuellt: {{aktuellt.0.[|value]}}
 Anamnes: {{anamnes.0.[|value]}}
 Komorbiditet: {{komorbiditet.0.[|value]}}
      {{/each}}
    {{/each}}
  {{/each}}
{{/with}}

  This ends the second comment block:   --}}

</textarea>
        <button id="run-conversion">Run Conversion --- > Output</button>
        <button id="show-compiled">Show precompiled template</button>
      </div>
        <div class="resizer"></div>
        <div id="output-container" class="column column-right">
            <textarea id="out">Output goes here after conversion is run</textarea>
        </div>
      </div>
    </main>
    <footer>
          <strong>K!ntegrate</strong> v0.2  A rudimentary integration tool with roots at <strong><a href="https://www.karolinskahospital.com/">K</a></a></strong>. 
          || Settings:
          <label style="cursor: pointer;"><input type="checkbox" id="toggle-line-numbers" checked>Show line numbers</label>
          | <label>Tree unfold depth:<input type="number" id="tree-close-depth" min="0" value="0" style="width:2em; margin-left:6px;"> 0=show all</label>
     </footer>
 
    <!-- CodeMirror 5 JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script><!-- If we want HTML+XML highlight too -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/handlebars/handlebars.min.js"></script>

    <!-- Tree widget and Handlebars runtime (local) -->
    <script src="tree.min.js"></script>

    <!-- Handlebars Runtime -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.7.8/handlebars.min.js"></script>
    
    <!-- Other scripts -->
    <script src="resizable-columns.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
      // --- Editor initialization ---
      const inputTextarea = document.getElementById('inputInstance');
      const templateTextarea = document.getElementById('template-editor');
      const outputTextarea = document.getElementById('out');

      const inputEditor = CodeMirror.fromTextArea(inputTextarea, { mode: 'application/json', lineNumbers: true, tabSize: 2 });
      const templateEditor = CodeMirror.fromTextArea(templateTextarea, { mode: 'text/x-handlebars-template', lineNumbers: true, tabSize: 2 });
      const outputEditor = CodeMirror.fromTextArea(outputTextarea, { mode: 'application/json', lineNumbers: true, readOnly: true });
      const selectionListBox = document.getElementById('selection-list')
      const actions = document.getElementById('tree-actions');

      console.log('111 actions:', actions, "selectionListBox", selectionListBox );

      // small helper creating flat paths in Handlebars syntax
      function buildHandlebarsPath(pathArray) {
        if (!Array.isArray(pathArray)) return '';
        return pathArray.map(p => {
          if (typeof p === 'number') return p;
          // old regex:
          // if (/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(String(p))) return String(p);
          // new regex: Allow Unicode letters (e.g., åäö), underscore and $ as first char, then letters, numbers, underscore, $
          if (/^[\p{L}_$][\p{L}\p{N}_$]*$/u.test(String(p))) return String(p);
        return `[${String(p).replace(/\\/g,'\\\\').replace(/]/g,'\\]')}]`;
        }).join('.');
      }

      // small helper creating tree-structs using {{#each ...}} or {{#with ...}} in Handlebars syntax based on a node deeper down in the structure
      function buildHandlebarsTree(node) {
        // Walk the node.path array from left (root) to right (leaf) and
        // emit opening wrappers for properties that are objects (#with) or arrays (#each).
        // Numeric indices in the path are represented by the preceding property's #each,
        // so we skip numeric entries when building the wrappers. The leaf is the final
        // non-numeric path segment (or the last segment if it's not an identifier).
        if (!node || !Array.isArray(node.path) || node.path.length === 0) return '';

        const path = node.path;
        const opens = [];
        let leaf = null;

        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          const next = path[i + 1];

          if (typeof p === 'number') {
            // numeric index is handled by the wrapper emitted for the previous property
            continue;
          }

          // If next is a number, this property is an array -> emit #each and skip the numeric index
          if (typeof next === 'number') {
            opens.push(`{{#each ${buildHandlebarsPath([p])}}}`);
            // skip the numeric index
            i++;
            continue;
          }

          // If there is another property after this, emit #with (object context)
          if (i < path.length - 1) {
            opens.push(`{{#with ${buildHandlebarsPath([p])}}}`);
            continue;
          }

          // Otherwise this is the leaf property
          leaf = buildHandlebarsPath([p]);
        }

        // If we still don't have a leaf (e.g. path ends in a number), pick last non-number segment
        if (!leaf) {
          for (let j = path.length - 1; j >= 0; j--) {
            if (typeof path[j] !== 'number') { leaf = buildHandlebarsPath([path[j]]); break; }
          }
        }

        // Build output: openings with indentation (outer -> inner), leaf at innermost level,
        // then matching closing tags with matching indentation (inner -> outer)
        const lines = [];
        for (let idx = 0; idx < opens.length; idx++) {
          const indent = '  '.repeat(idx);
          lines.push(indent + opens[idx]);
        }

        if (leaf) {
          const indent = '  '.repeat(opens.length);
          lines.push(indent + '{{' + leaf + '}}');
        }

        for (let k = opens.length - 1; k >= 0; k--) {
          const openTag = opens[k];
          const m = openTag.match(/^\{\{#(each|with)\s+/);
          const tag = m ? m[1] : 'with';
          const indent = '  '.repeat(k);
          lines.push(indent + `{{/${tag}}}`);
        }

        return lines.join('\n');
      }

      // Use the provided Tree widget (tree.min.js) for rendering and selection.
      const jsonTreeContainer = document.getElementById('json-tree-container');
      let treeInstance = null;

      // Convert arbitrary JSON into the tree widget's expected node format.
      let _idCounter = 1;
      function nextId() { return 'n' + (_idCounter++); }

      // Recursive function to convert JSON to tree nodes
      function jsonToTreeNodes(value, path = [], parent = null) {
        const type = Object.prototype.toString.call(value);

        // Handle plain objects
        if (type === '[object Object]') {
            const nodes = [];
            for (const key of Object.keys(value)) {
              const val = value[key];
              const basePath = path.concat(key);

              if (Array.isArray(val)) {
                // For arrays that are values of an object key, append indices to the parent label
                for (let i = 0; i < val.length; i++) {
                  const nodePath = basePath.concat(i);
                  const item = val[i];
                  const itemType = Object.prototype.toString.call(item);
                  // If the array item is a primitive, collapse it into the parent label as key[i]=value
                  if (itemType !== '[object Object]' && itemType !== '[object Array]') {
                    nodes.push({ id: nextId(), text: String(key) + '[' + i + ']=' + String(item), path: nodePath });
                  } else {
                    const children = jsonToTreeNodes(item, nodePath, value);
                    nodes.push({ id: nextId(), text: String(key) + '[' + i + ']', path: nodePath, children: children.length ? children : undefined });
                  }
                }
              } else {
                const valType = Object.prototype.toString.call(val);
                // If the property value is a primitive, collapse into parent label as key=value
                if (valType !== '[object Object]' && valType !== '[object Array]') {
                  nodes.push({ id: nextId(), text: String(key) + '=' + String(val), path: basePath });
                } else {
                  const children = jsonToTreeNodes(val, basePath, value);
                  nodes.push({ id: nextId(), text: String(key), path: basePath, children: children.length ? children : undefined });
                }
              }
            }
            return nodes;
        }

        // Handle arrays (when not directly under an object key)
        if (type === '[object Array]') {
          return value.map((item, i) => {
            const nodePath = path.concat(i);
            const itemType = Object.prototype.toString.call(item);
            if (itemType !== '[object Object]' && itemType !== '[object Array]') {
              return { id: nextId(), text: '[' + i + ']=' + String(item), path: nodePath };
            }
            const children = jsonToTreeNodes(item, nodePath, value);
            return { id: nextId(), text: '[' + i + ']', path: nodePath, children: children.length ? children : undefined };
          });
        }

        // Primitive value (top-level or fallback): represent as a single leaf node
        return [{ id: nextId(), text: String(value), path: path }];

      }

      function insertPathsFromNodes(nodes) {
        if (!nodes || nodes.length === 0) return;
        const inserts = nodes.map(n => `{{${buildHandlebarsPath(n.path)}}}`);
        templateEditor.replaceSelection(inserts.join('\n'));
        templateEditor.focus();
      }

      // Render the selected paths list. Accepts an array of node objects (deepest selected nodes).
      function renderSelectedPaths(nodes) {
        const selectedListEl = document.getElementById('selected-paths') || (() => {
          const el = document.createElement('div'); el.id = 'selected-paths'; el.style.marginTop = '8px'; document.getElementById('selection-list')?.appendChild(el); return el;
        })();

        if (!nodes || nodes.length === 0) {
          selectedListEl.textContent = 'No nodes selected. Use checkboxes to select nodes.';
          return;
        }

        const ul = document.createElement('ul');
        for (const n of nodes) {
          const li = document.createElement('li');

          // Tree button at start of row
          const treeIconBtn = document.createElement('button');
          treeIconBtn.type = 'button';
          treeIconBtn.className = 'path-icon';
          treeIconBtn.title = 'Selected path';
          treeIconBtn.style.border = '1px solid';
          treeIconBtn.style.background = 'transparent';
          treeIconBtn.style.padding = '3px';
          treeIconBtn.style.cursor = 'pointer';
          // simple inline SVG tree-like icon (small)
          treeIconBtn.innerHTML = '⤡';
          treeIconBtn.addEventListener('click', () => {
            templateEditor.replaceSelection(buildHandlebarsTree(n));
            templateEditor.focus();
          });
          li.appendChild(treeIconBtn);
          
          // Flat path button at second position of row
          const flatPathBtn = document.createElement('button');
          flatPathBtn.type = 'button';
          flatPathBtn.textContent = "↔ "+buildHandlebarsPath(n.path);
          flatPathBtn.style.cursor = 'pointer';
          flatPathBtn.style.border = '1px solid'
          flatPathBtn.addEventListener('click', () => {
            templateEditor.replaceSelection(`{{${buildHandlebarsPath(n.path)}}}`);
            templateEditor.focus();
          });
          li.appendChild(flatPathBtn);

          ul.appendChild(li);
        }

        selectedListEl.innerHTML = '';
        selectedListEl.appendChild(ul);
      }

      function updateJsonTree(jsonString) {
        jsonTreeContainer.innerHTML = '';

        try {
          const jsonData = JSON.parse(jsonString);
          _idCounter = 1;
          const treeData = jsonToTreeNodes(jsonData, []);

          // Actions UI (create locally so we don't depend on external references)
          let actionsEl = document.getElementById('tree-actions');
          if (!actionsEl) {
            actionsEl = document.createElement('div');
            actionsEl.id = 'tree-actions';
            actionsEl.className = 'tree-actions';
          } else {
            // clear previous children to avoid duplicates
            actionsEl.innerHTML = '';
          }

          // Insert button (keeps same behavior as before)
          const insertButton = document.createElement('button');
          insertButton.textContent = 'Insert all Selected Paths';
          insertButton.id = 'insert-selected-paths';
          insertButton.addEventListener('click', () => {
            if (!treeInstance) return;
            const selected = treeInstance.selectedNodes || [];

            function isAncestor(aPath, bPath) {
              if (!Array.isArray(aPath) || !Array.isArray(bPath)) return false;
              if (aPath.length >= bPath.length) return false;
              for (let i = 0; i < aPath.length; i++) {
                if (aPath[i] !== bPath[i]) return false;
              }
              return true;
            }

            const fullyChecked = selected.filter(n => n && n.status === 2 && Array.isArray(n.path));
            const deepest = fullyChecked.filter(n => !fullyChecked.some(m => m !== n && isAncestor(n.path, m.path)));

            insertPathsFromNodes(deepest);
          });

          let selectedList = document.getElementById('selected-paths');
          if (!selectedList) {
            selectedList = document.createElement('div');
            selectedList.id = 'selected-paths';
            selectedList.style.marginTop = '8px';
            selectedList.textContent = 'No nodes selected. Use checkboxes to select nodes.';
          } else {
            selectedList.innerHTML = '';
          }

          actionsEl.appendChild(insertButton);
          actionsEl.appendChild(selectedList);

          // Attach to selection list container (replace existing contents)
          const selBox = document.getElementById('selection-list');
          if (selBox) {
            selBox.innerHTML = '';
            selBox.appendChild(actionsEl);
          }

          // Initialize Tree widget into our container
          const selector = '#json-tree-container';
          const closeDepthOpt = parseInt(document.getElementById('tree-close-depth').value, 10) || 0;
          treeInstance = new Tree(selector, {
            data: treeData,
            closeDepth: closeDepthOpt,
            onChange: function() {
              const selected = this.selectedNodes || [];
              const selectedListEl = document.getElementById('selected-paths');

              if (!selected || selected.length === 0) {
                selectedListEl.textContent = 'No nodes selected. Use checkboxes to select nodes.';
                return;
              }

              // keep only fully-checked nodes (status===2) and remove any node
              // that is an ancestor of another selected node so we only show
              // the deepest selected nodes (avoid parents being shown when child selected)
              function isAncestor(aPath, bPath) {
                if (!Array.isArray(aPath) || !Array.isArray(bPath)) return false;
                if (aPath.length >= bPath.length) return false;
                for (let i = 0; i < aPath.length; i++) {
                  if (aPath[i] !== bPath[i]) return false;
                }
                return true;
              }

              const fullyChecked = selected.filter(n => n && n.status === 2 && Array.isArray(n.path));
              const deepest = fullyChecked.filter(n => !fullyChecked.some(m => m !== n && isAncestor(n.path, m.path)));

              // render selected deepest nodes via shared helper
              renderSelectedPaths(deepest);
              // keep selectionListBox reference in sync
              selectionListBox.appendChild(document.getElementById('selected-paths'));
            } // end of onChange
          });

          // ****************************
          // Right-click on a node: toggle that node only (don't cascade to descendants)
          // This preserves children selection states but updates ancestor statuses.
          jsonTreeContainer.addEventListener('contextmenu', (ev) => {
            if (!treeInstance) return;
            ev.preventDefault();
            let el = ev.target;
            console.log('Right-click target element:', el);
            // find the nearest LI with class treejs-node
            while (el && el !== jsonTreeContainer && !el.classList.contains('treejs-node')) el = el.parentNode;
            if (!el || !el.nodeId) return;
            const node = treeInstance.nodesById && treeInstance.nodesById[el.nodeId];
            if (!node) return;
            // make the element (el) visibly selected for a short moment to give user feedback
            el.style.backgroundColor = '#cce5cc';
            setTimeout(() => { el.style.backgroundColor = ''; }, 600);    

            console.log('Right-clicked node identified:', node);
            // add a green entry representing this right-click-selected node in the list under selected-paths, if not already there. 
            // Just like when leaf nodes are selected via normal left-click checkbox selection

            try {
              // toggle between unchecked (0) and checked (2) without walking down
              node.status = (node.status === 2 ? 0 : 2); //status 0 means unchecked, 2 means checked=
              treeInstance.markWillUpdateNode && treeInstance.markWillUpdateNode(node);
              // recompute ancestors so parent visual states stay correct
              treeInstance.walkUp && treeInstance.walkUp(node, 'status');
              // apply visual updates
              treeInstance.updateLiElements && treeInstance.updateLiElements();
              // compute deepest selected nodes and re-render the selected list
              const selected = treeInstance.selectedNodes || [];
              const fullyChecked = selected.filter(n => n && n.status === 2 && Array.isArray(n.path));
              const deepest = fullyChecked.filter(n => !fullyChecked.some(m => m !== n && (function(aPath,bPath){ if (!Array.isArray(aPath)||!Array.isArray(bPath)) return false; if (aPath.length>=bPath.length) return false; for (let i=0;i<aPath.length;i++) if (aPath[i]!==bPath[i]) return false; return true;})(n.path,m.path)));
              renderSelectedPaths(deepest);
              // notify change handlers
              if (treeInstance.options && typeof treeInstance.options.onChange === 'function') {
                treeInstance.options.onChange.call(treeInstance);
              }
            } catch (e) {
              console.error('Right-click toggle failed:', e);
            }
          });

          //***************************

          // When user changes the tree-close-depth control, update the option and re-render in-place
          const treeDepthInput = document.getElementById('tree-close-depth');
          treeDepthInput.addEventListener('change', () => {
            try {
              const newDepth = parseInt(treeDepthInput.value, 10) || 0;
              if (!treeInstance) return;
              // Update option and re-render the existing tree nodes so we don't lose selection state
              treeInstance.options = treeInstance.options || {};
              treeInstance.options.closeDepth = newDepth;
              // render will rebuild DOM using current treeNodes and the updated closeDepth
              treeInstance.render(treeInstance.treeNodes);
              // Ensure visual check/disabled state is synced to the new DOM
              if (treeInstance.nodesById) {
                Object.values(treeInstance.nodesById).forEach(n => {
                  try { treeInstance.updateLiElement && treeInstance.updateLiElement(n); } catch (err) { /* ignore per-node errors */ }
                });
              }
            } catch (e) {
              console.error('Failed to update tree depth:', e);
            }
          });

          } catch (e) {
            selectedPaths.innerHTML = '<p style="color:red;">Invalid input JSON. Error message:<br>'+e.message+'</p>';
          }
      }

      function insertSelectedPathsAtCursor() {
        if (!selectedPaths || selectedPaths.length === 0) return;
        const inserts = selectedPaths.map(p => `{{${buildHandlebarsPath(p)}}}`);
        templateEditor.replaceSelection(inserts.join('\n'));
        templateEditor.focus();
      };
      
      // Set initial content
      const initialJson = `{ 
  "message": "JSON pasted/loaded into the box get turned into a tree-view.",
  "starter_tips": {
      "tip_array":[
         "Click an checkbox below to select a node (and all of its decendents).",
         "Click an already selected checkbox to unselect it (and all of its decendents).",
         "Right-click to pop up a menu that can be used to create paths/structures at the cursor/selection position in the conversion column ➠"
        ],
      "tip_object_please_open_descendants":
       {"Right_click_explanations" :
         {
          "⤡" : "Generate hierarchical nesting structrure",
          "↔" : "Generate flat path to value of this node"
         },
        "Not yet implemented" :
         {
          "↔🔑" : "Generate flat path to value of this node",
          "⬚√" : "Frame this node as context root - very useful when working inside deep tree-structures" 
         }
       }
    }
}`;
      
      
      inputEditor.setValue(initialJson);
      outputEditor.setValue('Output goes here after conversion is run.');

      // --- Event Handlers ---
      document.getElementById('run-conversion').addEventListener('click', () => {
        try {
          // 1. Get template and input from editors
          const templateString = templateEditor.getValue();
          const jsonString = inputEditor.getValue();

          if (!jsonString.trim()) {
            outputEditor.setValue('Input JSON is empty.');
            return;
          }
          const data = JSON.parse(jsonString);

          // 2. Compile the template
          const template = Handlebars.compile(templateString);

          // 3. Execute the template with the data
          const resultHtml = template(data);

          // 4. Display the resulting HTML in the output editor
          outputEditor.setValue(resultHtml);
        } catch (e) {
          outputEditor.innerHTML = '<p style="color:red;">Invalid JSON. Error message:<br>'+e.message+'</p>';
        }
      });

      // File input handling
      document.getElementById('fileInput').addEventListener('change', function(ev) {
        const file = ev.target.files && ev.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const content = e.target.result;
            inputEditor.setValue(content);
            updateJsonTree(content);
          };
          reader.readAsText(file);
        }
      });

      // Example selection
      document.getElementById('exampleSelect').addEventListener('change', function() {
        const selectedFile = this.value;
        if (selectedFile) {
          fetch(`example/instance/${selectedFile}`)
            .then(response => response.ok ? response.text() : Promise.reject('Network response was not ok'))
            .then(data => {
              inputEditor.setValue(data);
              updateJsonTree(data);
            })
            .catch(error => {
              console.error('There was a problem with the fetch operation:', error);
              const msg = 'Error loading file: ' + selectedFile;
              inputEditor.setValue(JSON.stringify({ error: msg }, null, 2));
            });
        }
      });

      // Run conversion button
      document.getElementById('run-conversion').addEventListener('click', () => {
        const templateString = templateEditor.getValue();
        let inputData;
        try {
          inputData = JSON.parse(inputEditor.getValue());
        } catch (e) {
          alert('Invalid input JSON: ' + e.message);
          return;
        }
        try {
          if (window.Handlebars && typeof Handlebars.compile === 'function') {
            const fn = Handlebars.compile(templateString);
            const result = fn(inputData);
            outputEditor.setValue(result);
          } else if (window.Handlebars && typeof Handlebars.template === 'function' && typeof Handlebars.precompile === 'function') {
            // As a fallback, try precompilation (may not be available in runtime-only builds)
            const pre = Handlebars.precompile(templateString);
            outputEditor.setValue(pre);
          } else {
            outputEditor.setValue('Handlebars not available in this environment.');
          }
        } catch (e) {
          alert('Conversion error: ' + e.message);
        }
      });

      // when show-compiled button is clicked, show the compiled template
      var showCompiledButton = document.getElementById('show-compiled');
      showCompiledButton.addEventListener('click', () => {
        const templateString = templateEditor.getValue();
        try {
          var precompiledTemplate = Handlebars.precompile ? Handlebars.precompile(templateString) : 'Precompile not available';
          const conversionContainer = document.getElementById('conversion-container');
          const compiledTextarea = document.createElement('textarea');
          compiledTextarea.id = 'precompiled-textarea';
          compiledTextarea.style.width = '100%';
          compiledTextarea.style.height = '50%';
          compiledTextarea.readOnly = true;
          compiledTextarea.value = precompiledTemplate;
          conversionContainer.insertBefore(compiledTextarea, showCompiledButton);
          showCompiledButton.style.display = 'none'; // hide the button after click
          // add a copy to clipboard button to the alert that copies the template to clipboard
          const copyButton = document.createElement('button');
          copyButton.textContent = 'Copy precompiled template to Clipboard (+close)';
          copyButton.id = 'copy-precompiled-button';
          conversionContainer.appendChild(copyButton);
          copyButton.style.cursor = 'pointer';
          copyButton.onclick = () => {
            navigator.clipboard.writeText(precompiledTemplate).then(() => {
              // show text "Copied!" on the button for 1 second then remove the textarea and copy button;
              copyButton.textContent = 'Copied!';
              setTimeout(() => {
                conversionContainer.removeChild(compiledTextarea);
                conversionContainer.removeChild(copyButton);
                showCompiledButton.style.display = 'inline'; // show the show-compiled button again
              }, 1000);
            });
          };
        } catch (e) {
          alert('Error during precompilation:\n\n' + e.message);
          console.error('Precompilation Error:', e);
        }
      });

      // When content of template-editor changes: If compiled-textarea exists, remove it + copy button and show the show-compiled button again
      templateEditor.on('change', () => {
        console.log("Template editor changed, removing precompiled view if exists.");
        const conversionContainer = document.getElementById('conversion-container');
        const compiledTextarea = document.getElementById('precompiled-textarea');
        const copyButton = document.getElementById('copy-precompiled-button');
        if (compiledTextarea && copyButton) {
          conversionContainer.removeChild(compiledTextarea);
          conversionContainer.removeChild(copyButton);
          showCompiledButton.style.display = 'inline'; // show the show-compiled button again
        }
      });

      document.getElementById('toggle-line-numbers').addEventListener('change', function() {
        const showLineNumbers = this.checked;
        const editors = [inputEditor, templateEditor, outputEditor];
        editors.forEach(editor => editor.setOption('lineNumbers', showLineNumbers));
      });

      // Update tree when user types in the input editor
      inputEditor.on('change', (editor) => {
        updateJsonTree(editor.getValue());
      });

      }); // DOMContentLoaded
    </script>
  </body>
</html>
