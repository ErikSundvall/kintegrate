<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Kintegrate</title>
    <script>
      const APP_VERSION = 'v0.3.3';
    </script>
    <link rel="stylesheet" href="resizable-columns.css">
    <!--  css for tree widget -->
    <link rel="stylesheet" href="tree.min.css">
    <!-- CodeMirror 5 CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <style>
      /* Style for editor buttons (icons from Material UI Icons: https://mui.com/material-ui/material-icons/) */
      .editor-buttons {
        margin-bottom: 8px;
      }
      .editor-buttons button {
        margin-right: 8px;
        display: inline-flex;
        align-items: center;
        padding: 6px 12px;
      }
      .editor-buttons button svg {
        width: 20px;
        height: 20px;
        fill: currentColor;
      }
      .editor-buttons button:disabled svg {
        opacity: 0.5;
      }

      /* Tree node type styles */
      .node-primitive {
        color: #333;
      }
      .node-array {
        color: #0066cc;
        font-weight: 500;
      }
      .node-array::before {
        content: "[A] ";
        font-size: 0.8em;
        color: #666;
      }
      .node-object {
        color: #006633;
        font-weight: 500;
      }
      .node-object::before {
        content: "{O} ";
        font-size: 0.8em;
        color: #666;
      }
      
      /* Visual styling for primitives */
      .node-primitive {
        color: #333;
      }
      .node-primitive::before {
        content: "(P) ";
        font-size: 0.8em;
        color: #666;
      }

      /* Context boundary styling */
      .context-boundary {
        border: 1px dotted #666 !important;
        border-radius: 3px;
        background-color: rgba(200, 200, 200, 0.1);
      }
    </style>


  </head>
  <body>
    <main>
      <div class="fullheight-container" id="main-container">
        <div id="input-container" class="column column-left">
            <!-- file picker that can pick files from user upload -->
            Pick example file <input type="file" id="fileInput" accept=".json,.xml,.txt"><br>
            or select example:
            <!-- Dropdown that can load any existing file in web server side subdirectory /example/instance into the textarea that has id="inputInstance"  -->
            <select id="exampleSelect">
              <option value="">--Select an example--</option>
              <option value="intro.json">intro.json</option>
              <option value="MDK_Rek_demo1.json">MDK_Rek_demo1.json</option>
              <option value="mdk_lunga_1.json">mdk_lunga_1.json</option>
              <option value="non_existing_example.json">non_existing_example.json</option>
            </select><br>
            or just paste input into the box below<br>
            <textarea id="inputInstance">Input example goes here</textarea>
            <hr>
            <div id="json-tree-container">Parsed input from above goes here into a foldable tree. The tree-branches can then be clicked to get paths that can be used in conversion template</div>
        </div>
        <div class="resizer"></div>
        <div id="conversion-container" class="column column-center">
            <div id="selection-list">
              <div id="number-of-selected-paths"></div>
              <div class="tree-actions">
                <div id="selected-paths">No nodes selected. Use checkboxes to select nodes.</div>
              </div>
            </div>
            <div>Conversion Template (Handlebars)</div>
            <textarea id="template-editor">
{{!-- <--- This is how you start a comment block in Handlebars
  This is the column where you author (and possibly compile) your conversion script.
  Currently you see a simple Handlebars template.
  After importing instance data and/or schema (or other structure defitnitions) they can help you author the conversion script.
  Select nodes in the tree on the left to insert paths to data elements at the current cursor position in this template.
 This ends comment block:   --}}
 
If intro.json is loaded as source this example will work, otherwise likely a lot of blank spots:
----- Start -----
Remember, ⤡ means: {{starter_tips.tip_object.Right_click_explanations.[⤡]}}

A number of tips:
{{#with starter_tips}}
  {{#each tip_array}}
- {{.}}
  {{/each}}
{{/with}}
----- The end -----

{{!-- Another comment block. Remove this line to run it
  
The examples below fit with the example input file MDK_Rek_demo1.json

Example with full flat path: 
  {{granskning.bakgrund.0.sjukdomshistoria.0.ospecificerad_händelse.0.anamnes.0.[|value]}}

Example looping/traversing tree combined with parital flat 
paths when we have reached a relevant repeating level:
  {{#with granskning}}
    {{#each rubrik}}
      {{#each behållare}}
        {{#each deltagare}} {{! this is a list with potentially many rows }}
Närvarande:
          {{#each deltagare}} 
{{namn.0.[|value]}} (Specialitet: {{vårdgivarroll.0.specialitet.0.[|value]}})
          {{/each}}
        {{/each}}
      {{/each}}
    {{/each}}
  {{/with}}

Bakgrund:
{{#with granskning}}
  {{#each bakgrund}}
    {{#each sjukdomshistoria}}
      {{#each ospecificerad_händelse}}
 Aktuellt: {{aktuellt.0.[|value]}}
 Anamnes: {{anamnes.0.[|value]}}
 Komorbiditet: {{komorbiditet.0.[|value]}}
      {{/each}}
    {{/each}}
  {{/each}}
{{/with}}

  This ends the second comment block:   --}}

</textarea>
            <div class="editor-buttons">
                <button id="undo-button" title="Undo last change (Ctrl+Z)">
                    <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                        <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8"></path>
                    </svg>
                </button>
                <button id="redo-button" title="Redo last undone change (Ctrl+Y)">
                    <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                        <path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7z"></path>
                    </svg>
                </button>
                <button id="erase-button" title="Clear editor content (can be undone)">
                    <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                        <path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
                    </svg>
                </button>
                <button id="download-button" title="Download editor content">
                    <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                        <path d="M19 9h-4V3H9v6H5l7 7zM5 18v2h14v-2z"></path>
                    </svg>
                </button>
                <button id="run-conversion">Run Conversion --- > Output</button>
            </div>          
    
        <button id="show-compiled">Show precompiled template</button>
      </div>
        <div class="resizer"></div>
        <div id="output-container" class="column column-right">
            <textarea id="out">Output goes here after conversion is run</textarea>
        </div>
      </div>
    </main>
    <footer>
          <strong>K!ntegrate</strong> <span id="app-version"></span>  A rudimentary integration tool with roots at <strong><a href="https://www.karolinskahospital.com/">K</a></a></strong>. 
          || Settings:
          <label style="cursor: pointer;"><input type="checkbox" id="toggle-line-numbers" checked>Show line numbers</label>
          | <label>Tree unfold depth:<input type="number" id="tree-close-depth" min="0" value="0" style="width:2em; margin-left:6px;"> 0=show all</label>
     </footer>
 
    <!-- CodeMirror 5 JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script><!-- If we want HTML+XML highlight too -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/handlebars/handlebars.min.js"></script>
    <!-- Add undo/redo addon -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/undo/undo.min.js"></script>

    <!-- Tree widget and Handlebars runtime (local) -->
    <script src="tree.min.js"></script>
    <script src="extended-tree.js"></script>

    <!-- Handlebars Runtime -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.7.8/handlebars.min.js"></script>
    
    <!-- Other scripts -->
    <script src="resizable-columns.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
      // Set version in footer
      document.getElementById('app-version').innerHTML = '<a href="https://github.com/ErikSundvall/kintegrate#'+APP_VERSION+'">'+APP_VERSION+'</a>';

      // --- Editor initialization ---
      const inputTextarea = document.getElementById('inputInstance');
      const templateTextarea = document.getElementById('template-editor');
      const outputTextarea = document.getElementById('out');

      const inputEditor = CodeMirror.fromTextArea(inputTextarea, { mode: 'application/json', lineNumbers: true, tabSize: 2 });
      // Get the pre-defined buttons
      const undoButton = document.getElementById('undo-button');
      const redoButton = document.getElementById('redo-button');
      const eraseButton = document.getElementById('erase-button');

      // Initialize CodeMirror with undo/redo history
      const templateEditor = CodeMirror.fromTextArea(templateTextarea, {
        mode: 'text/x-handlebars-template',
        lineNumbers: true,
        tabSize: 2,
        undoDepth: 200,  // Number of undo levels to keep
        historyEventDelay: 200  // Delay in ms to merge changes into one undo event
      });

      // Setup undo/redo button handlers
      undoButton.onclick = () => {
        if (templateEditor.historySize().undo > 0) {
          templateEditor.undo();
          templateEditor.focus();
        }
      };
      redoButton.onclick = () => {
        if (templateEditor.historySize().redo > 0) {
          templateEditor.redo();
          templateEditor.focus();
        }
      };

      // Update button states based on history availability
      function updateButtonStates() {
        const history = templateEditor.historySize();
        undoButton.disabled = history.undo === 0;
        redoButton.disabled = history.redo === 0;
      }

      // Listen for changes to update button states
      templateEditor.on('change', updateButtonStates);
      updateButtonStates();

      // Setup erase button handler
      eraseButton.onclick = () => {
        templateEditor.setValue('');
        templateEditor.focus();
      };

      // Setup download button handler
      const downloadButton = document.getElementById('download-button');
      downloadButton.onclick = () => {
        // Create filename with current date/time
        const now = new Date();
        const timestamp = now.toISOString()
          .replace(/:/g, '-')  // Replace colons with dashes
          .replace(/\./g, '-') // Replace dot with dash
          .replace(/T/, '_')   // Replace T with underscore
          .slice(0, -1);       // Remove the Z at the end
        const filename = `Kintegrate_${timestamp}.txt`;

        // Create blob and download link
        const content = templateEditor.getValue();
        const blob = new Blob([content], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        window.URL.revokeObjectURL(url);
      };
      const outputEditor = CodeMirror.fromTextArea(outputTextarea, { mode: 'application/json', lineNumbers: true, readOnly: true });
      const selectionListBox = document.getElementById('selection-list')
      const actions = document.getElementById('tree-actions');

      console.log('111 actions:', actions, "selectionListBox", selectionListBox );

      // small helper creating flat paths in Handlebars syntax
      function buildHandlebarsPath(pathArray, node) {
        if (!Array.isArray(pathArray)) return '';
        
        // Find the nearest context boundary ancestor
          function findNearestContextBoundary(currentNode) {
            if (!currentNode || !currentNode.path) return null;
            
            // First check if the current node itself is a boundary
            if (treeInstance.isContextBoundary(currentNode.id)) {
              return currentNode;
            }
            
            // Look up parent by ID instead of reconstructing from path
            let current = currentNode;
            while (current && current.parentId) {
              current = treeInstance.nodesById[current.parentId];
              if (current && treeInstance.isContextBoundary(current.id)) {
                return current;
              }            if (current && treeInstance.isContextBoundary(current.id)) {
              return current;
            }
          }
          return null;
        }
        
        // If we have a node, check for context boundary
        let processedPath = [...pathArray]; // Create a copy we can modify
        if (node) {
          const boundaryNode = findNearestContextBoundary(node);
          if (boundaryNode) {
            // Find the indices of all array indices in the boundary node's path
            const boundaryArrayIndices = boundaryNode.path
              .map((v, i) => typeof v === 'number' ? i : -1)
              .filter(i => i !== -1);
            
            if (boundaryNode.id === node.id) {
              // If the node itself is the boundary, keep only what's after it
              processedPath = processedPath.slice(processedPath.length - 1);
            } else {
              // Otherwise trim path to start from boundary, but preserve array structure
              const boundaryDepth = boundaryNode.path.length;
              processedPath = processedPath.slice(boundaryDepth);
              
              // Insert array indices from boundary path where needed
              boundaryArrayIndices.forEach(idx => {
                if (idx < boundaryDepth) {
                  processedPath.unshift(boundaryNode.path[idx]);
                }
              });
            }
          }
        }
        
        // Convert path segments to Handlebars syntax
        return processedPath.map(p => {
          if (typeof p === 'number') return p;
          if (/^[\p{L}_$][\p{L}\p{N}_$]*$/u.test(String(p))) return String(p);
          return `[${String(p).replace(/\\/g,'\\\\').replace(/]/g,'\\]')}]`;
        }).join('.');
      }

      // small helper creating tree-structs using {{#each ...}} or {{#with ...}} in Handlebars syntax based on a node deeper down in the structure
      function buildHandlebarsTree(node) {
        if (!node || !Array.isArray(node.path) || node.path.length === 0) return '';

        // Find the nearest context boundary ancestor
        function findNearestContextBoundary(currentNode) {
          if (!currentNode || !currentNode.path) return null;
          
          // First check if the current node itself is a boundary
          if (treeInstance.isContextBoundary(currentNode.id)) {
            return currentNode;
          }
          
          let current = currentNode;
          while (current) {
            // Get parent node by removing last element from path
            const parentPath = current.path.slice(0, -1);
            // Find node with this path including array indices
            current = Object.values(treeInstance.nodesById).find(
              n => n.path && n.path.length === parentPath.length && 
              n.path.every((v, i) => v === parentPath[i])
            );
            
            if (current && treeInstance.isContextBoundary(current.id)) {
              return current;
            }
          }
          return null;
        }

        // Get the context boundary ancestor if any
        const boundaryNode = findNearestContextBoundary(node);
        
        // If we have a context boundary, adjust the path appropriately
        let path;
        if (boundaryNode) {
          // Find array indices in the boundary path that we need to preserve
          const boundaryArrayIndices = boundaryNode.path
            .map((v, i) => typeof v === 'number' ? { index: i, value: v } : null)
            .filter(x => x !== null);
          
          if (boundaryNode.id === node.id) {
            // If the node itself is the boundary, only use its last path segment
            path = [node.path[node.path.length - 1]];
          } else {
            // Otherwise trim path to start from boundary but preserve array indices
            path = node.path.slice(boundaryNode.path.length);
            
            // Insert necessary array indices from the boundary path
            boundaryArrayIndices.forEach(({ index, value }) => {
              if (index < boundaryNode.path.length) {
                // Insert array index at correct position relative to its parent
                const parentIndex = Math.max(0, index - 1);
                if (parentIndex < path.length) {
                  path.splice(parentIndex + 1, 0, value);
                }
              }
            });
          }
        } else {
          path = node.path;
        }

        const opens = [];
        let leaf = null;

        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          const next = path[i + 1];

          if (typeof p === 'number') {
            // numeric index is handled by the wrapper emitted for the previous property
            continue;
          }

          // If next is a number, this property is an array -> emit #each and skip the numeric index
          if (typeof next === 'number') {
            opens.push(`{{#each ${buildHandlebarsPath([p])}}}`);
            // skip the numeric index
            i++;
            continue;
          }

          // If there is another property after this, emit #with (object context)
          if (i < path.length - 1) {
            opens.push(`{{#with ${buildHandlebarsPath([p])}}}`);
            continue;
          }

          // Otherwise this is the leaf property
          leaf = buildHandlebarsPath([p]);
        }

        // If we still don't have a leaf (e.g. path ends in a number), pick last non-number segment
        if (!leaf) {
          for (let j = path.length - 1; j >= 0; j--) {
            if (typeof path[j] !== 'number') { leaf = buildHandlebarsPath([path[j]]); break; }
          }
        }

        // Build output: openings with indentation (outer -> inner), leaf at innermost level,
        // then matching closing tags with matching indentation (inner -> outer)
        const lines = [];
        for (let idx = 0; idx < opens.length; idx++) {
          const indent = '  '.repeat(idx);
          lines.push(indent + opens[idx]);
        }

        if (leaf) {
          const indent = '  '.repeat(opens.length);
          lines.push(indent + '{{' + leaf + '}}');
        }

        for (let k = opens.length - 1; k >= 0; k--) {
          const openTag = opens[k];
          const m = openTag.match(/^\{\{#(each|with)\s+/);
          const tag = m ? m[1] : 'with';
          const indent = '  '.repeat(k);
          lines.push(indent + `{{/${tag}}}`);
        }

        return lines.join('\n');
      }

      // Use the provided Tree widget (tree.min.js) for rendering and selection.
      const jsonTreeContainer = document.getElementById('json-tree-container');
      let treeInstance = null;

      // Node type constants
      const NODE_TYPE = {
        PRIMITIVE: 'primitive',
        ARRAY: 'array',
        OBJECT: 'object'
      };

      // Convert arbitrary JSON into the tree widget's expected node format.
      let _idCounter = 1;
      function nextId() { return 'n' + (_idCounter++); }

      // Create a node with common properties
      function createNode(id, text, path, nodeType, parent = null, children = undefined) {
        // Store parent ID instead of direct reference to avoid circular structure
        const parentId = parent ? parent.id : null;
        return {
          id,
          text,
          path,
          nodeType,
          parentId, // Store parent ID instead of direct reference
          children  // undefined for leaf nodes
        };
      }

      // Recursive function to convert JSON to tree nodes
      function jsonToTreeNodes(value, path = [], parent = null) {
        const type = Object.prototype.toString.call(value);

        // Create a lookup map for finding nodes by path
        if (!jsonToTreeNodes.nodesByPath) {
          jsonToTreeNodes.nodesByPath = new Map();
        }

        // Handle plain objects
        if (type === '[object Object]') {
            const nodes = [];
            for (const key of Object.keys(value)) {
              const val = value[key];
              const basePath = path.concat(key);
              const nodeId = nextId();

              if (Array.isArray(val)) {
                // For arrays that are values of an object key
                const arrayNode = createNode(nodeId, String(key), basePath, NODE_TYPE.ARRAY, parent);
                const arrayChildren = [];
                
                for (let i = 0; i < val.length; i++) {
                  const nodePath = basePath.concat(i);
                  const item = val[i];
                  const itemType = Object.prototype.toString.call(item);
                  const itemId = nextId();

                  if (itemType !== '[object Object]' && itemType !== '[object Array]') {
                    // Primitive array item
                    arrayChildren.push(createNode(itemId, `[${i}] = ${String(item)}`, nodePath, NODE_TYPE.PRIMITIVE, arrayNode));
                  } else {
                    // Complex array item
                    const itemNode = createNode(itemId, `[${i}]`, nodePath, itemType === '[object Array]' ? NODE_TYPE.ARRAY : NODE_TYPE.OBJECT, arrayNode);
                    const children = jsonToTreeNodes(item, nodePath, itemNode);
                    if (children.length) itemNode.children = children;
                    arrayChildren.push(itemNode);
                  }
                }

                if (arrayChildren.length) arrayNode.children = arrayChildren;
                nodes.push(arrayNode);
              } else {
                const valType = Object.prototype.toString.call(val);
                if (valType !== '[object Object]' && valType !== '[object Array]') {
                  // Primitive value
                  nodes.push(createNode(nodeId, `${key} = ${String(val)}`, basePath, NODE_TYPE.PRIMITIVE, parent));
                } else {
                  // Object or array value
                  const objNode = createNode(nodeId, key, basePath, NODE_TYPE.OBJECT, parent);
                  const children = jsonToTreeNodes(val, basePath, objNode);
                  if (children.length) objNode.children = children;
                  nodes.push(objNode);
                }
              }
            }
            return nodes;
        }

        // Handle arrays (when not directly under an object key)
        if (type === '[object Array]') {
          return value.map((item, i) => {
            const nodePath = path.concat(i);
            const itemType = Object.prototype.toString.call(item);
            const nodeId = nextId();

            if (itemType !== '[object Object]' && itemType !== '[object Array]') {
              // Primitive array item
              return createNode(nodeId, `[${i}] = ${String(item)}`, nodePath, NODE_TYPE.PRIMITIVE, parent);
            } else {
              // Complex array item
              const arrayNode = createNode(nodeId, `[${i}]`, nodePath, itemType === '[object Array]' ? NODE_TYPE.ARRAY : NODE_TYPE.OBJECT, parent);
              const children = jsonToTreeNodes(item, nodePath, arrayNode);
              if (children.length) arrayNode.children = children;
              return arrayNode;
            }
          });
        }

        // Primitive value (top-level or fallback): represent as a single leaf node
        return [createNode(nextId(), String(value), path, NODE_TYPE.PRIMITIVE, parent)];

      }

      function insertPathsFromNodes(nodes) {
        if (!nodes || nodes.length === 0) return;
        const inserts = nodes.map(n => `{{${buildHandlebarsPath(n.path)}}}`);
        templateEditor.replaceSelection(inserts.join('\n'));
        templateEditor.focus();
      }

      // Render the selected paths list. Accepts an array of node objects (deepest selected nodes).
      function renderSelectedPaths(nodes) {
        const selectedListEl = document.getElementById('selected-paths') || (() => {
          const el = document.createElement('div'); el.id = 'selected-paths'; el.style.marginTop = '8px'; document.getElementById('selection-list')?.appendChild(el); return el;
        })();

        // update count indicator
        const countEl = document.getElementById('number-of-selected-paths');
        if (countEl) {
          countEl.textContent = nodes && nodes.length ? `${nodes.length} selected` : '';
        }

        // show/hide actions area depending on selection
        const actionsWrap = document.querySelector('.tree-actions');
        if (actionsWrap) {
          if (!nodes || nodes.length === 0) {
            actionsWrap.style.display = 'none';
          } else {
            actionsWrap.style.display = '';
          }
        }

        // update toggle button label to include count
        const toggleBtn = document.getElementById('toggle-selected-list');
        if (toggleBtn) {
          const n = nodes && nodes.length ? nodes.length : 0;
          const visible = (selectedListEl && selectedListEl.style.display !== 'none');
          toggleBtn.textContent = (visible ? 'Hide selected list' : 'Show selected list') + ` (${n})`;
        }

        if (!nodes || nodes.length === 0) {
          selectedListEl.textContent = 'No nodes selected. Use checkboxes to select nodes.';
          // ensure actions area hidden when no selection
          const actionsWrap = document.querySelector('.tree-actions');
          if (actionsWrap) actionsWrap.style.display = 'none';
          return;
        }

        const ul = document.createElement('ul');
        for (const n of nodes) {
          const li = document.createElement('li');

          // Tree button at start of row
          const treeIconBtn = document.createElement('button');
          treeIconBtn.type = 'button';
          treeIconBtn.className = 'path-icon';
          treeIconBtn.title = 'Selected path';
          treeIconBtn.style.border = '1px solid';
          treeIconBtn.style.background = 'transparent';
          treeIconBtn.style.padding = '3px';
          treeIconBtn.style.cursor = 'pointer';
          treeIconBtn.innerHTML = '⤡';
          treeIconBtn.addEventListener('click', () => {
            templateEditor.replaceSelection(buildHandlebarsTree(n));
            templateEditor.focus();
          });
          li.appendChild(treeIconBtn);

          // Flat path button at second position of row
          const flatPathBtn = document.createElement('button');
          flatPathBtn.type = 'button';
          flatPathBtn.textContent = "↔ "+buildHandlebarsPath(n.path);
          flatPathBtn.style.cursor = 'pointer';
          flatPathBtn.style.border = '1px solid'
          flatPathBtn.addEventListener('click', () => {
            templateEditor.replaceSelection(`{{${buildHandlebarsPath(n.path)}}}`);
            templateEditor.focus();
          });
          li.appendChild(flatPathBtn);

          ul.appendChild(li);
        }

  // show actions area when we have selections
  const actionsWrap2 = document.querySelector('.tree-actions');
  if (actionsWrap2) actionsWrap2.style.display = '';

  selectedListEl.innerHTML = '';
  selectedListEl.appendChild(ul);
      }

      function updateJsonTree(jsonString) {
        try {
          const jsonData = JSON.parse(jsonString);
          _idCounter = 1;
          const treeData = jsonToTreeNodes(jsonData, []);
          
          // Clear the container before adding new content
          jsonTreeContainer.innerHTML = '';

          // Actions UI (create locally so we don't depend on external references)
          let actionsEl = document.getElementById('tree-actions');
          if (!actionsEl) {
            actionsEl = document.createElement('div');
            actionsEl.id = 'tree-actions';
            actionsEl.className = 'tree-actions';
          } else {
            // clear previous children to avoid duplicates
            actionsEl.innerHTML = '';
          }

          // Insert button (keeps same behavior as before)
          const insertButton = document.createElement('button');
          insertButton.textContent = '↔ Insert all Selected node as "flat" Paths';
          insertButton.id = 'insert-selected-paths';
          insertButton.addEventListener('click', () => {
            if (!treeInstance) return;
            const selected = treeInstance.selectedNodes || [];

            function isAncestor(aPath, bPath) {
              if (!Array.isArray(aPath) || !Array.isArray(bPath)) return false;
              if (aPath.length >= bPath.length) return false;
              for (let i = 0; i < aPath.length; i++) {
                if (aPath[i] !== bPath[i]) return false;
              }
              return true;
            }

            const fullyChecked = selected.filter(n => n && n.status === 2 && Array.isArray(n.path));
            const deepest = fullyChecked.filter(n => !fullyChecked.some(m => m !== n && isAncestor(n.path, m.path)));

            insertPathsFromNodes(deepest);
          });

          let selectedList = document.getElementById('selected-paths');
          if (!selectedList) {
            selectedList = document.createElement('div');
            selectedList.id = 'selected-paths';
            selectedList.style.marginTop = '8px';
            selectedList.textContent = 'No nodes selected. Use checkboxes to select nodes.';
            // hidden by default
            selectedList.style.display = 'none';
          } else {
            selectedList.innerHTML = '';
            // hidden by default when re-creating
            selectedList.style.display = 'none';
          }

          // Toggle button to show/hide the selected-paths list
          let toggleButton = document.getElementById('toggle-selected-list');
          if (!toggleButton) {
            toggleButton = document.createElement('button');
            toggleButton.type = 'button';
            toggleButton.id = 'toggle-selected-list';
            // initial text will be updated by renderSelectedPaths to include count
            toggleButton.textContent = 'Show selected list (0)';
            toggleButton.style.marginLeft = '8px';
            toggleButton.style.cursor = 'pointer';
            toggleButton.addEventListener('click', () => {
              if (!selectedList) return;
              if (selectedList.style.display === 'none') {
                selectedList.style.display = '';
              } else {
                selectedList.style.display = 'none';
              }
              // always refresh label to reflect current count and visibility
              const n = (treeInstance && treeInstance.selectedNodes) ? (treeInstance.selectedNodes.filter(n=>n&&n.status===2&&Array.isArray(n.path)).length) : 0;
              const visible = (selectedList && selectedList.style.display !== 'none');
              toggleButton.textContent = (visible ? 'Hide selected list' : 'Show selected list') + ` (${n})`;
            });
          }

          actionsEl.appendChild(toggleButton);
          actionsEl.appendChild(insertButton);
          
          actionsEl.appendChild(selectedList);

          // Attach to selection list container (replace existing contents)
          const selBox = document.getElementById('selection-list');
          if (selBox) {
            selBox.innerHTML = '';
            selBox.appendChild(actionsEl);
          }

          // Initialize Tree widget into our container
          const selector = '#json-tree-container';
          const closeDepthOpt = parseInt(document.getElementById('tree-close-depth').value, 10) || 0;
          
          // Clear node path lookup before initializing tree
          jsonToTreeNodes.nodesByPath = new Map();
          
          // Initialize tree with our extended version that includes context boundary support
          treeInstance = new ExtendedTree(selector, {
            data: treeData,
            closeDepth: closeDepthOpt,
            
            // Add node type classes during rendering
            onCreateLi: function(node, li) {
              if (node.nodeType) {
                li.classList.add('node-' + node.nodeType);
              }
            },

            onChange: function() {
              const selected = this.selectedNodes || [];
              const selectedListEl = document.getElementById('selected-paths');

              if (!selected || selected.length === 0) {
                selectedListEl.textContent = 'No nodes selected. Use checkboxes to select nodes.';
                return;
              }

              // keep only fully-checked nodes (status===2) and remove any node
              // that is an ancestor of another selected node so we only show
              // the deepest selected nodes (avoid parents being shown when child selected)
              function isAncestor(aPath, bPath) {
                if (!Array.isArray(aPath) || !Array.isArray(bPath)) return false;
                if (aPath.length >= bPath.length) return false;
                for (let i = 0; i < aPath.length; i++) {
                  if (aPath[i] !== bPath[i]) return false;
                }
                return true;
              }

              const fullyChecked = selected.filter(n => n && n.status === 2 && Array.isArray(n.path));
              const deepest = fullyChecked.filter(n => !fullyChecked.some(m => m !== n && isAncestor(n.path, m.path)));

              // render selected deepest nodes via shared helper
              renderSelectedPaths(deepest);
              // keep selectionListBox reference in sync
              selectionListBox.appendChild(document.getElementById('selected-paths'));
            } // end of onChange
          });

          // ****************************
          // Right-click on a node: toggle that node only (don't cascade to descendants)
          // This preserves children selection states but updates ancestor statuses.
          
          // Right-click on a node: show context menu with options
          jsonTreeContainer.addEventListener('contextmenu', (ev) => {
              if (!treeInstance) return;
              ev.preventDefault();
              
              // Find clicked element
              let el = ev.target;
              while (el && el !== jsonTreeContainer) {
                  if (el.tagName === 'LI' && el.classList.contains('treejs-node')) break;
                  el = el.parentElement;
              }
              
              // Exit if no valid tree node found
              if (!el || el === jsonTreeContainer) return;
              
              // Get node data from the tree widget
              const nodeId = el.nodeId;
              if (!nodeId || !treeInstance.nodesById) return;
              
              const node = treeInstance.nodesById[nodeId];
              if (!node) return;
              
              // Remove any existing menus
              const existingMenu = document.querySelector('.kintegrate-context-menu');
              if (existingMenu) {
                  existingMenu.parentNode.removeChild(existingMenu);
              }
              
              // Create and position the context menu
              const menu = document.createElement('div');
              menu.className = 'kintegrate-context-menu';
              menu.style.position = 'fixed';  // Changed from 'absolute' to 'fixed'
              menu.style.left = ev.clientX + 'px';  // Use clientX instead of pageX
              menu.style.top = ev.clientY + 'px';   // Use clientY instead of pageY
              menu.style.zIndex = '1000';

              // Add menu options
              const flatPathOption = document.createElement('div'); 
              flatPathOption.className = 'kintegrate-context-option';
              flatPathOption.textContent = '↔ Insert flat path: ' + buildHandlebarsPath(node.path, node);
              flatPathOption.addEventListener('click', () => {
                  templateEditor.replaceSelection(`{{${buildHandlebarsPath(node.path, node)}}}`);
                  templateEditor.focus();
                  menu.remove();
              });
              menu.appendChild(flatPathOption);

              const treeStructOption = document.createElement('div');  
              treeStructOption.className = 'kintegrate-context-option';
              treeStructOption.textContent = '⤡ Insert tree structure';
              treeStructOption.addEventListener('click', () => {
                  const treeStr = buildHandlebarsTree(node);
                  if (treeStr) {
                      templateEditor.replaceSelection(treeStr);
                      templateEditor.focus();
                  }
                  menu.remove();
              });
              menu.appendChild(treeStructOption);

              // Add context boundary option
              const contextBoundaryOption = document.createElement('div');
              contextBoundaryOption.className = 'kintegrate-context-option';
              const isCurrentlyBoundary = treeInstance.isContextBoundary(nodeId);
              contextBoundaryOption.textContent = (isCurrentlyBoundary ? '✓ Remove' : '⬚√ Set') + ' as context boundary';
              contextBoundaryOption.addEventListener('click', () => {
                  const newState = !treeInstance.isContextBoundary(nodeId);
                  treeInstance.setContextBoundary(nodeId, newState);
                  el.classList.toggle('context-boundary', newState);
                  menu.remove();
              });
              menu.appendChild(contextBoundaryOption);
              
              // Add the menu to the document
              document.body.appendChild(menu);

              // Ensure menu is visible within viewport
              const menuRect = menu.getBoundingClientRect();
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              
              if (menuRect.right > viewportWidth) {
                  menu.style.left = (viewportWidth - menuRect.width - 10) + 'px';
              }
              if (menuRect.bottom > viewportHeight) {
                  menu.style.top = (viewportHeight - menuRect.height - 10) + 'px';
              }

              // Handle menu removal
              const removeMenu = () => {
                  if (menu && menu.parentNode) {
                      menu.parentNode.removeChild(menu);
                  }
                  document.removeEventListener('click', removeMenu);
                  document.removeEventListener('mousemove', trackMouse);
              };

              // Track mouse movement
              const trackMouse = (e) => {
                  if (!menu) return;
                  const rect = menu.getBoundingClientRect();
                  const buffer = 10; // 10px buffer zone
                  
                  if (e.clientX < rect.left - buffer || 
                      e.clientX > rect.right + buffer || 
                      e.clientY < rect.top - buffer || 
                      e.clientY > rect.bottom + buffer) {
                      removeMenu();
                  }
              };

              // Set up event listeners for menu removal
              document.addEventListener('click', removeMenu);
              document.addEventListener('mousemove', trackMouse);
          });
          //***************************

          // When user changes the tree-close-depth control, update the option and re-render in-place
          const treeDepthInput = document.getElementById('tree-close-depth');
          treeDepthInput.addEventListener('change', () => {
            try {
              const newDepth = parseInt(treeDepthInput.value, 10) || 0;
              if (!treeInstance) return;
              // Update option and re-render the existing tree nodes so we don't lose selection state
              treeInstance.options = treeInstance.options || {};
              treeInstance.options.closeDepth = newDepth;
              // render will rebuild DOM using current treeNodes and the updated closeDepth
              treeInstance.render(treeInstance.treeNodes);
              // Ensure visual check/disabled state is synced to the new DOM
              if (treeInstance.nodesById) {
                Object.values(treeInstance.nodesById).forEach(n => {
                  try { treeInstance.updateLiElement && treeInstance.updateLiElement(n); } catch (err) { /* ignore per-node errors */ }
                });
              }
            } catch (e) {
              console.error('Failed to update tree depth:', e);
            }
          });

          } catch (e) {
            // Display error in the tree container
            jsonTreeContainer.innerHTML = `
              <div style="color: red; padding: 10px; border: 1px solid red; margin: 10px; background-color: #fff0f0;">
                <strong>Invalid JSON</strong><br>
                <pre style="margin-top: 8px; white-space: pre-wrap;">${e.message}</pre>
              </div>`;
            
            // Also update the selected paths area to show no selection
            const selectedPaths = document.getElementById('selected-paths');
            if (selectedPaths) {
              selectedPaths.innerHTML = 'No nodes selected. (Fix JSON syntax error to enable selection)';
            }
            
            // Hide the actions area since we can't select anything
            const actionsWrap = document.querySelector('.tree-actions');
            if (actionsWrap) {
              actionsWrap.style.display = 'none';
            }
          }
      }

      function insertSelectedPathsAtCursor() {
        if (!selectedPaths || selectedPaths.length === 0) return;
        const inserts = selectedPaths.map(p => `{{${buildHandlebarsPath(p)}}}`);
        templateEditor.replaceSelection(inserts.join('\n'));
        templateEditor.focus();
      };
      
      // Load intro.json by default
      fetch('example/instance/intro.json')
        .then(response => response.ok ? response.text() : Promise.reject('Network response was not ok'))
        .then(data => {
          inputEditor.setValue(data);
          updateJsonTree(data);
        })
        .catch(error => {
          console.error('Error loading intro.json:', error);
          // Fallback to empty JSON if file can't be loaded
          inputEditor.setValue('{}');
        });
      outputEditor.setValue('Output goes here after conversion is run.');

      // --- Event Handlers ---
      document.getElementById('run-conversion').addEventListener('click', () => {
        try {
          // 1. Get template and input from editors
          const templateString = templateEditor.getValue();
          const jsonString = inputEditor.getValue();

          if (!jsonString.trim()) {
            outputEditor.setValue('Input JSON is empty.');
            return;
          }
          const data = JSON.parse(jsonString);

          // 2. Compile the template
          const template = Handlebars.compile(templateString);

          // 3. Execute the template with the data
          const resultHtml = template(data);

          // 4. Display the resulting HTML in the output editor
          outputEditor.setValue(resultHtml);
        } catch (e) {
          outputEditor.innerHTML = '<p style="color:red;">Invalid JSON. Error message:<br>'+e.message+'</p>';
        }
      });

      // File input handling
      document.getElementById('fileInput').addEventListener('change', function(ev) {
        const file = ev.target.files && ev.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const content = e.target.result;
            inputEditor.setValue(content);
            updateJsonTree(content);
          };
          reader.readAsText(file);
        }
      });

      // Example selection
      document.getElementById('exampleSelect').addEventListener('change', function() {
        const selectedFile = this.value;
        if (selectedFile) {
          fetch(`example/instance/${selectedFile}`)
            .then(response => response.ok ? response.text() : Promise.reject('Network response was not ok'))
            .then(data => {
              inputEditor.setValue(data);
              updateJsonTree(data);
            })
            .catch(error => {
              console.error('There was a problem with the fetch operation:', error);
              const msg = 'Error loading file: ' + selectedFile;
              inputEditor.setValue(JSON.stringify({ error: msg }, null, 2));
            });
        }
      });

      // Run conversion button
      document.getElementById('run-conversion').addEventListener('click', () => {
        const templateString = templateEditor.getValue();
        let inputData;
        try {
          inputData = JSON.parse(inputEditor.getValue());
        } catch (e) {
          alert('Invalid input JSON: ' + e.message);
          return;
        }
        try {
          if (window.Handlebars && typeof Handlebars.compile === 'function') {
            const fn = Handlebars.compile(templateString);
            const result = fn(inputData);
            outputEditor.setValue(result);
          } else if (window.Handlebars && typeof Handlebars.template === 'function' && typeof Handlebars.precompile === 'function') {
            // As a fallback, try precompilation (may not be available in runtime-only builds)
            const pre = Handlebars.precompile(templateString);
            outputEditor.setValue(pre);
          } else {
            outputEditor.setValue('Handlebars not available in this environment.');
          }
        } catch (e) {
          alert('Conversion error: ' + e.message);
        }
      });

      // when show-compiled button is clicked, show the compiled template
      var showCompiledButton = document.getElementById('show-compiled');
      showCompiledButton.addEventListener('click', () => {
        const templateString = templateEditor.getValue();
        try {
          var precompiledTemplate = Handlebars.precompile ? Handlebars.precompile(templateString) : 'Precompile not available';
          const conversionContainer = document.getElementById('conversion-container');
          const compiledTextarea = document.createElement('textarea');
          compiledTextarea.id = 'precompiled-textarea';
          compiledTextarea.style.width = '100%';
          compiledTextarea.style.height = '50%';
          compiledTextarea.readOnly = true;
          compiledTextarea.value = precompiledTemplate;
          conversionContainer.insertBefore(compiledTextarea, showCompiledButton);
          showCompiledButton.style.display = 'none'; // hide the button after click
          // add a copy to clipboard button to the alert that copies the template to clipboard
          const copyButton = document.createElement('button');
          copyButton.textContent = 'Copy precompiled template to Clipboard (+close)';
          copyButton.id = 'copy-precompiled-button';
          conversionContainer.appendChild(copyButton);
          copyButton.style.cursor = 'pointer';
          copyButton.onclick = () => {
            navigator.clipboard.writeText(precompiledTemplate).then(() => {
              // show text "Copied!" on the button for 1 second then remove the textarea and copy button;
              copyButton.textContent = 'Copied!';
              setTimeout(() => {
                conversionContainer.removeChild(compiledTextarea);
                conversionContainer.removeChild(copyButton);
                showCompiledButton.style.display = 'inline'; // show the show-compiled button again
              }, 1000);
            });
          };
        } catch (e) {
          alert('Error during precompilation:\n\n' + e.message);
          console.error('Precompilation Error:', e);
        }
      });

      // When content of template-editor changes: If compiled-textarea exists, remove it + copy button and show the show-compiled button again
      templateEditor.on('change', () => {
        console.log("Template editor changed, removing precompiled view if exists.");
        const conversionContainer = document.getElementById('conversion-container');
        const compiledTextarea = document.getElementById('precompiled-textarea');
        const copyButton = document.getElementById('copy-precompiled-button');
        if (compiledTextarea && copyButton) {
          conversionContainer.removeChild(compiledTextarea);
          conversionContainer.removeChild(copyButton);
          showCompiledButton.style.display = 'inline'; // show the show-compiled button again
        }
      });

      document.getElementById('toggle-line-numbers').addEventListener('change', function() {
        const showLineNumbers = this.checked;
        const editors = [inputEditor, templateEditor, outputEditor];
        editors.forEach(editor => editor.setOption('lineNumbers', showLineNumbers));
      });

      // Update tree when user types in the input editor
      inputEditor.on('change', (editor) => {
        updateJsonTree(editor.getValue());
      });

      }); // DOMContentLoaded
    </script>
  </body>
</html>
