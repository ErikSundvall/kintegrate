<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Kintegrate</title>
    <script>
      const APP_VERSION = 'v0.3.7';
    </script>
    <link rel="stylesheet" href="resizable-columns.css">
    <!--  css for tree widget -->
    <link rel="stylesheet" href="tree.min.css">
    <!-- CodeMirror 5 CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <!-- Application styles -->
    <link rel="stylesheet" href="kintegrate.css">
    <style>
      .success {
        background-color: #4caf50 !important;
        border-color: #2e7d32 !important;
      }
      .toggle-button.active .auto-convert-icon-fill {
        fill: #4caf50;
        opacity: 0.3;
      }
      .toggle-button {
        background: none;
        border: 1px solid #ccc;
        padding: 4px;
        cursor: pointer;
        border-radius: 4px;
      }
      .toggle-button.active {
        background-color: #e8f5e9;
        border-color: #4caf50;
      }
      .toggle-button:hover {
        border-color: #999;
      }
      .toggle-button.active:hover {
        border-color: #2e7d32;
      }
      /* Sync mode button styles */
      #sync-mode-btn.sync-off {
        background: #f5f5f5;
        color: #666;
      }
      #sync-mode-btn.sync-on {
        background: #4CAF50;
        color: white;
        border-color: #2e7d32;
      }
      #sync-mode-btn.sync-on:hover {
        background: #43a047;
      }
    </style>


  </head>
  <body>
    <main>
      <div class="fullheight-container" id="main-container">
        <!-- div id="input-wrapper" -->
          <div class="column column-left">
            <div id="input-container">
              Pick 
              <button id="example-select" title="Load example input from server">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
                  <path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2m-3 2v5l-1-.75L15 9V4zm3 12H8V4h5v9l3-2.25L19 13V4h1z"></path>
                </svg>
              </button>, upload <input type="file" id="fileInput" style="display: inline-block; width: 12em;" />
              | <button id="open-form-viewer-btn" title="Open EHR form viewer in popup window" style="padding: 2px 8px;">üìã Form Viewer</button>
              <button id="push-to-form-btn" title="Send current instance to form viewer" style="padding: 2px 8px;">‚Üí Push</button>
              <button id="pull-from-form-btn" title="Get current composition from form viewer" style="padding: 2px 8px;">‚Üê Pull</button>
              <button id="sync-mode-btn" class="sync-off" title="Toggle sync mode - auto-update from form changes" style="padding: 2px 8px;">üîÑ Sync: OFF</button>
              <button id="download-instance-btn" title="Download current instance as JSON file" style="padding: 2px 8px;">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
                  <path d="M18 15v3H6v-3H4v3c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-3zm-1-4-1.41-1.41L13 12.17V4h-2v8.17L8.41 9.59 7 11l5 5z"></path>
                </svg>
              </button>
              <br>or just paste input into the box below<br>
              <textarea id="inputInstance">Input example goes here</textarea>
              <hr>
              <div id="json-tree-container">Parsed input from above goes here into a foldable tree. The tree-branches can then be clicked to get paths that can be used in conversion template</div>
            </div>
            <div id="input-footer">
              <div class="footer-controls">
                <label title="Adjust tree depth (0 = show all)">
                  Depth: <input type="range" id="tree-depth-slider" min="1" max="6" value="6" class="compact-slider">
                  <span class="slider-value" id="depth-value">All</span>
                </label>
                <label title="Adjust tree item size">
                  | Size: <input type="range" id="tree-size-slider" min="10" max="150" value="100" class="compact-slider">
                  <span class="slider-value" id="size-value">100%</span>
                </label>
                <span style="white-space: nowrap;">|</span>
                <div id="selection-list" style="display: inline-block; margin-left: 8px;">
                  <div class="tree-actions" style="display: inline-block;">
                    <button id="insert-selected-paths" style="display: none; padding: 2px 6px; font-size: 0.9em;">‚Üî Insert selected</button>
                  </div>
                  <div id="selected-paths" style="display: none;">No nodes selected. Use checkboxes to select nodes.</div>
                </div>
              </div>
            </div>
          </div>
        <!-- /div -->

        <div class="resizer"></div>

        <div class="column column-center">
          <div id="conversion-container">
              <div id="extended-editor">
<textarea id="template-editor">
{{!-- <--- This is how you start a comment block in Handlebars
  This is the column where you author (and possibly compile) your conversion script.
  Currently you see a simple Handlebars template.
  After importing instance data and/or schema (or other structure defitnitions) they can help you author the conversion script.
  Select nodes in the tree on the left to insert paths to data elements at the current cursor position in this template.
 This ends comment block:   --}}
 
If intro.json is loaded as source this example will work, otherwise likely a lot of blank spots:
----- Start -----
Remember, ‚§° means: {{starter_tips.tip_object.Right_click_explanations.[‚§°]}}

A number of tips:
{{#with starter_tips}}
  {{#each tip_array}}
- {{.}}
  {{/each}}
{{/with}}
----- The end -----


----- Another example block -----

The examples below fit with the example input file MDK_Rek_demo1.json

Example with full flat path: 
  {{granskning.bakgrund.0.sjukdomshistoria.0.ospecificerad_h√§ndelse.0.anamnes.0.[|value]}}

Example looping/traversing tree combined with parital flat 
paths when we have reached a relevant repeating level:
  {{#with granskning}}
    {{#each rubrik}}
      {{#each beh√•llare}}
        {{#each deltagare}} {{! this is a list with potentially many rows }}
N√§rvarande:
          {{#each deltagare}} 
{{namn.0.[|value]}} (Specialitet: {{v√•rdgivarroll.0.specialitet.0.[|value]}})
          {{/each}}
        {{/each}}
      {{/each}}
    {{/each}}
  {{/with}}

Bakgrund:
{{#with granskning}}
  {{#each bakgrund}}
    {{#each sjukdomshistoria}}
      {{#each ospecificerad_h√§ndelse}}
 Aktuellt: {{aktuellt.0.[|value]}}
 Anamnes: {{anamnes.0.[|value]}}
 Komorbiditet: {{komorbiditet.0.[|value]}}
      {{/each}}
    {{/each}}
  {{/each}}
{{/with}}

{{!-- Example of helper functions for comparisons that can be used (in parenthesis) in e.g. #if-blocks 

      eq: v1 === v2, equals
      ne: v1 !== v2, not equals
      lt: v1 < v2, less than
      gt: v1 > v2, greater than
      lte: v1 <= v2, less than or equal to
      gte: v1 >= v2, greater than or equal to
      and(expression1, expression2, ...expressions) => all expressions must be true
      or(expression1, expression2, ...expressions) => at least one expression must be true

--}}
{{!-- Example of numeric comparisons (if there are values) --}}
{{#with granskning.utredning_unders√∂kning.0.funktionsutredning.0.spirometriresultat.[0].ospecificerad_h√§ndelse.[0].kvot_fev1_fvc.[0].resultat.[0]}}
  {{#if [|numerator]}}
FEV1/FVC: {{[|numerator]}}
    {{#if (gte [|numerator] 70)}}
  FEV1/FVC kvot √§r √∂ver eller lika med 70% - d√• kanske patienten kan pusta ut? Om den har n√•gon luft kvar?
    {{else}}
  FEV1/FVC kvot √§r under 70% (eller saknas?) - kanske inte s√• bra v√§rde, men ett Handlebars script ska nog inte ge medicinskt beslutsst√∂d
    {{/if}}
  {{else}}
FEV1/FVC-resutat saknas!
  {{/if}}
{{/with}}

{{!-- Or simpler by going deeper and using "." (current context) instead of repeating the path. Also compressed line breaks in syntax a bit,  --}}
{{#with granskning.utredning_unders√∂kning.0.funktionsutredning.0.spirometriresultat.[0].ospecificerad_h√§ndelse.[0].kvot_fev1_fvc.[0].resultat.[0].[|numerator]}}
 {{~#if .}}FEV1/FVC: {{.}}
  {{#if (gte . 70)}}  FEV1/FVC kvot √§r √∂ver eller lika med 70% - d√• kanske patienten kan pusta ut? Om den har n√•gon luft kvar?
  {{else}}FEV1/FVC kvot √§r under 70% (eller saknas?) - kanske inte s√• bra v√§rde, men ett Handlebars script ska nog inte ge medicinskt beslutsst√∂d
  {{/if}}
 {{else}}FEV1/FVC-resutat saknas!
 {{/if}}
{{/with}}

{{!-- Using "~" for removing whitespace. Using "#if (and x y z)" to check if all of values x y and z are available --}}
TNM-Klassificering:
{{~#with granskning.bed√∂mning.0.beh√•llare.0.klinisk_tnm-klassificering.[0]}}
 (Version: {{tnm-version.0.[|value]}})
{{#if (and prim√§rtum√∂r_t.0.[|value] regional_lymfk√∂rtlar_n.0.[|value] fj√§rrmetastaser_m.0.[|value])}}
T: {{prim√§rtum√∂r_t.0.[|value]}}
N: {{regional_lymfk√∂rtlar_n.0.[|value]}}
M: {{fj√§rrmetastaser_m.0.[|value]}}
Stadium: {{stadieindelning.0.[|value]}}
{{/if}}
{{/with}} 

{{!-- Example of using @data variables described in https://handlebarsjs.com/api-reference/data-variables.html 
      by looping over participants (deltagare) separating with a comma and ending with and and period.--}}
N√§rvarande:
{{~#with granskning.rubrik.[0].beh√•llare.[0].deltagare.[0]}}    
  {{#each deltagare}}
    {{~#if @first}} {{namn.0.[|value]}}
    {{~else if @last}} och {{namn.0.[|value]}}.
    {{else}} , {{namn.0.[|value]}}
    {{/if}}
  {{/each}}
  
{{!-- Example of using @index variable to number items in a list --}}
N√§rvarolista i ankomstordning:
  {{#each deltagare}}
    {{~@index}}. {{namn.0.[|value]}}
  {{/each}}    
{{/with}}
</textarea>
<div id="conversion-buttons" class="editor-buttons">
  <button id="erase-button" title="Clear editor content (can be undone)">
    <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
      <path d="M16 9H8v10h8zm-.47 7.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12 1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14z" opacity=".3"></path>
      <path d="M14.12 10.47 12 12.59l-2.13-2.12-1.41 1.41L10.59 14l-2.12 2.12 1.41 1.41L12 15.41l2.12 2.12 1.41-1.41L13.41 14l2.12-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4zM6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM8 9h8v10H8z"></path>
    </svg>
  </button>
  <button id="upload-button" title="Load template from file">
    <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
      <path d="M18 15v3H6v-3H4v3c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-3zM7 9l1.41 1.41L11 7.83V16h2V7.83l2.59 2.58L17 9l-5-5z"></path>
    </svg>
  </button>
  <button id="load-examples-button" title="Load example template from server">
    <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
      <path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2m-3 2v5l-1-.75L15 9V4zm3 12H8V4h5v9l3-2.25L19 13V4h1z"></path>
    </svg>
  </button>
  <button id="undo-button" title="Undo last change (Ctrl+Z)">
    <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
      <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8"></path>
    </svg>
  </button>
              <button id="redo-button" title="Redo last undone change (Ctrl+Y)">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                  <path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7z"></path>
                </svg>
              </button>
              <button id="copy-button" title="Copy conversion template to clipboard">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                  <path d="M9 4h9v12H9z" opacity=".3"></path>
                  <path d="M18 2H9c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2m0 14H9V4h9zM3 15v-2h2v2zm0-5.5h2v2H3zM10 20h2v2h-2zm-7-1.5v-2h2v2zM5 22c-1.1 0-2-.9-2-2h2zm3.5 0h-2v-2h2zm5 0v-2h2c0 1.1-.9 2-2 2M5 6v2H3c0-1.1.9-2 2-2"></path>
                </svg>
              </button>
              <button id="download-button" title="Download editor content">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                  <path d="M18 15v3H6v-3H4v3c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-3zm-1-4-1.41-1.41L13 12.17V4h-2v8.17L8.41 9.59 7 11l5 5z"></path>
                </svg>
              </button>
              <button id="show-compiled" title="Toggle precompiled template view" class="toggle-button">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                  <path  d="M4 18h16V8H4zm8-3h6v2h-6zm-5.91-4.59L7.5 9l4 4-4 4-1.41-1.41L8.67 13z" opacity=".3"></path>
                  <path d="M12 15h6v2h-6z"></path>
                  <path d="M20 4H4c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.89-2-2-2m0 14H4V8h16z"></path>
                  <path d="m7.5 17 4-4-4-4-1.41 1.41L8.67 13l-2.58 2.59z"></path>
                </svg>
              </button>
              <button id="auto-convert-button" title="Toggle auto-conversion" class="toggle-button">
                  <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                      <path class="auto-convert-icon-fill" d="M12 4c-4.41 0-8 3.59-8 8s3.59 8 8 8 8-3.59 8-8-3.59-8-8-8m-1 12H9V8h2zm1 0V8l5 4z" opacity=".3"></path>
                      <path d="M12 4c4.41 0 8 3.59 8 8s-3.59 8-8 8-8-3.59-8-8 3.59-8 8-8m0-2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m-1 6H9v8h2zm6 4-5-4v8z"></path>
                  </svg>
              </button>
            </div> 
            </div> <!-- #extended-editor -->
            <div id="precompile-container" style="position: relative;">
              <textarea id="precompiled-textarea" style="display: none; width: 100%; height: 200px; margin-top: 10px; padding: 8px; padding-right: 70px; resize: vertical; box-sizing: border-box;"></textarea>
              <div id="precompiled-buttons" style="display: none; position: absolute; right: 24px; top: 18px; z-index: 10; background: white; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: none; flex-direction: row;">
                <button id="copy-precompiled-button" title="Copy precompiled template to clipboard" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center;">
                  <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width: 20px; height: 20px;">
                    <path d="M9 4h9v12H9z" opacity=".3"></path>
                    <path d="M18 2H9c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2m0 14H9V4h9zM3 15v-2h2v2zm0-5.5h2v2H3zM10 20h2v2h-2zm-7-1.5v-2h2v2zM5 22c-1.1 0-2-.9-2-2h2zm3.5 0h-2v-2h2zm5 0v-2h2c0 1.1-.9 2-2 2M5 6v2H3c0-1.1.9-2 2-2"></path>
                  </svg>
                </button>
                <button id="close-precompiled-button" title="Close precompiled view" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center;">
                  <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width: 20px; height: 20px;">
                    <path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
                  </svg>
                </button>
              </div>
            </div>
          </div>
          <div id="conversion-footer" style="display: flex; align-items: baseline; gap: 8px;">
            <label style="cursor: pointer; white-space: nowrap; display: flex; align-items: baseline; gap: 6px;">Auto-convert delay (ms):<input type="number" id="auto-convert-delay" min="100" max="5000" value="500" style="width:4em;"></label>
            <span style="white-space: nowrap;">|</span>
            <span id="conversion-status" style="white-space: nowrap;">Latest conversion: Ready</span>
          </div>
        </div> <!-- .column-center -->
        <div class="resizer"></div>
        <div class="column column-right">
            <div id="output-container">
              <textarea id="out">Output goes here after conversion is run</textarea>
            </div>
            <div id="output-footer">This column shows the output from conversions.</div>
          </div>
      </div>
    </main>
    <footer>
          <strong>K!ntegrate</strong> <span id="app-version"></span>  A rudimentary integration tool with roots at <strong><a href="https://www.karolinskahospital.com/">K</a></a></strong>. 
          || Settings:
          <label style="cursor: pointer;"><input type="checkbox" id="toggle-line-numbers" checked>Show line numbers</label>
          | <label style="cursor: pointer;"><input type="checkbox" id="toggle-column-footers" checked>Show column footers</label>
     </footer>
 
    <!-- CodeMirror 5 JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <!-- Add simple mode addon first, required by handlebars mode -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/mode/simple.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/handlebars/handlebars.min.js"></script>
    <!-- Add undo/redo addon -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/undo/undo.min.js"></script>

    <!-- Tree widget and Handlebars runtime (local) -->
    <script src="tree.min.js"></script>
    <script src="extended-tree.js"></script>

    <!-- Handlebars Runtime -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.7.8/handlebars.min.js"></script>
    
    <!-- Other scripts -->
    <script src="resizable-columns.js"></script>
    <script>
      // ============================================
      // Form Viewer Popup Management
      // ============================================
      let formViewerWindow = null;
      let syncModeEnabled = false;

      function openFormViewer() {
        // Focus existing if open
        if (formViewerWindow && !formViewerWindow.closed) {
          formViewerWindow.focus();
          return;
        }
        
        // Open new popup (position to the right of main window)
        const width = 900;
        const height = 700;
        const left = window.screenX + window.innerWidth - 50;
        const top = window.screenY + 50;
        
        formViewerWindow = window.open(
          'form-viewer.html',
          'FormViewer',
          `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`
        );
        
        console.log('[Main] Opened form viewer popup');
      }

      // Listen for messages from popup
      window.addEventListener('message', (event) => {
        if (event.origin !== window.location.origin) return;
        
        const { type, payload } = event.data || {};
        console.log('[Main] Received message:', type, payload);
        
        switch (type) {
          case 'FORM_VIEWER_READY':
            console.log('[Main] Form viewer is ready');
            // Notify popup of current sync mode
            sendToFormViewer('SYNC_MODE_STATUS', { enabled: syncModeEnabled });
            break;
            
          case 'COMPOSITION_CHANGED':
            // Real-time update from form (sync mode)
            if (syncModeEnabled) {
              console.log('[Main] Received composition change (sync mode)');
              updateInputFromComposition(payload.composition);
            }
            break;
            
          case 'COMPOSITION_DATA':
            // Response to explicit REQUEST_COMPOSITION (manual pull)
            console.log('[Main] Received composition data');
            updateInputFromComposition(payload.composition);
            break;
            
          case 'REQUEST_PING':
            console.log('[Main] Received ping request, sending pong');
            sendToFormViewer('PONG', { timestamp: Date.now() });
            break;
        }
      });

      function sendToFormViewer(type, payload) {
        if (formViewerWindow && !formViewerWindow.closed) {
          formViewerWindow.postMessage({ type, payload }, window.location.origin);
          console.log('[Main] Sent message:', type);
        } else {
          console.log('[Main] Cannot send message - form viewer not open');
        }
      }
      
      // ============================================
      // Phase 4: Sync Mode Functions
      // ============================================
      
      function toggleSyncMode() {
        syncModeEnabled = !syncModeEnabled;
        
        const btn = document.getElementById('sync-mode-btn');
        if (syncModeEnabled) {
          btn.textContent = 'üîÑ Sync: ON';
          btn.classList.remove('sync-off');
          btn.classList.add('sync-on');
        } else {
          btn.textContent = 'üîÑ Sync: OFF';
          btn.classList.remove('sync-on');
          btn.classList.add('sync-off');
        }
        
        // Notify popup of sync mode change
        sendToFormViewer('SYNC_MODE_STATUS', { enabled: syncModeEnabled });
        
        console.log('[Main] Sync mode:', syncModeEnabled ? 'ON' : 'OFF');
      }

      // ============================================
      // Phase 2: Composition Handling Functions
      // ============================================
      
      // Download current instance as JSON file
      function downloadCurrentInstance() {
        // inputEditor is defined in DOMContentLoaded, access via closure won't work here
        // We'll wire this up inside DOMContentLoaded instead
      }
      
      // Push instance from input to form viewer
      function pushToForm(inputEditor) {
        const content = inputEditor ? inputEditor.getValue() : 
                        document.getElementById('inputInstance').value;
        
        if (!content || content.trim() === '') {
          alert('No instance data to push');
          return;
        }
        
        try {
          const composition = JSON.parse(content);
          
          // Open form viewer if not open
          if (!formViewerWindow || formViewerWindow.closed) {
            openFormViewer();
            // Wait for window to load, then send
            setTimeout(() => {
              sendToFormViewer('LOAD_COMPOSITION', { composition });
            }, 1500);
          } else {
            sendToFormViewer('LOAD_COMPOSITION', { composition });
          }
          console.log('[Main] Pushed composition to form');
        } catch (e) {
          alert('Instance is not valid JSON: ' + e.message);
        }
      }
      
      // Pull composition from form viewer to input
      function pullFromForm() {
        if (!formViewerWindow || formViewerWindow.closed) {
          alert('Form viewer is not open');
          return;
        }
        
        // Request composition from popup
        sendToFormViewer('REQUEST_COMPOSITION', {});
        // Response will be handled by message listener (COMPOSITION_DATA)
        console.log('[Main] Requested composition from form');
      }
      
      // Update input editor with composition data (used by pull and sync)
      // Note: inputEditor reference will be passed when called from DOMContentLoaded scope
      let updateInputFromComposition = (composition) => {
        console.log('[Main] updateInputFromComposition called but inputEditor not yet available');
      };

      document.addEventListener('DOMContentLoaded', () => {
      // Set version in footer
      document.getElementById('app-version').innerHTML = '<a href="https://github.com/ErikSundvall/kintegrate#'+APP_VERSION+'">'+APP_VERSION+'</a>';

      //handlebars helper from https://stackoverflow.com/a/31632215

    Handlebars.registerHelper({
      eq: (v1, v2) => v1 === v2,
      ne: (v1, v2) => v1 !== v2,
      lt: (v1, v2) => v1 < v2,
      gt: (v1, v2) => v1 > v2,
      lte: (v1, v2) => v1 <= v2,
      gte: (v1, v2) => v1 >= v2,
      and() {
        return Array.prototype.every.call(arguments, Boolean);
      },
      or() {
        return Array.prototype.slice.call(arguments, 0, -1).some(Boolean);
      },
      toLowerCase: (str) => str && str.toLowerCase(),
      toUpperCase: (str) => str && str.toUpperCase()
    });

      // --- Editor initialization ---
      const inputTextarea = document.getElementById('inputInstance');
      const templateTextarea = document.getElementById('template-editor');
      const outputTextarea = document.getElementById('out');

      const inputEditor = CodeMirror.fromTextArea(inputTextarea, { mode: 'application/json', lineNumbers: true, tabSize: 2 });

      // ============================================
      // Update input from composition (Phase 4: Sync Mode)
      // This reassigns the global function now that inputEditor is available
      // ============================================
      updateInputFromComposition = (composition) => {
        if (!composition) {
          console.log('[Main] No composition data received');
          return;
        }
        
        const jsonStr = JSON.stringify(composition, null, 2);
        
        // Update input editor
        inputEditor.setValue(jsonStr);
        
        // Trigger tree update (will be called by change event)
        // Conversion will also be triggered by change event if auto-convert is on
        
        // Brief visual feedback for sync updates
        const inputCol = document.querySelector('.column-left');
        if (inputCol) {
          inputCol.style.transition = 'background-color 0.3s';
          inputCol.style.backgroundColor = '#e8f5e9';
          setTimeout(() => {
            inputCol.style.backgroundColor = '';
          }, 300);
        }
        
        console.log('[Main] Input updated from composition');
      };

      // Get the pre-defined buttons  
      const undoButton = document.getElementById('undo-button');
      const redoButton = document.getElementById('redo-button');
      const eraseButton = document.getElementById('erase-button');

      // Initialize CodeMirror with undo/redo history
      const templateEditor = CodeMirror.fromTextArea(templateTextarea, {
        mode: 'text/x-handlebars-template',
        lineNumbers: true,
        tabSize: 2,
        undoDepth: 200,  // Number of undo levels to keep
        historyEventDelay: 200  // Delay in ms to merge changes into one undo event
      });

      // Auto-conversion functionality
      let autoConvertEnabled = true; // Enabled by default
      let autoConvertTimeout = null;
      
      function debounce(func, wait) {
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(autoConvertTimeout);
            func(...args);
          };
          clearTimeout(autoConvertTimeout);
          autoConvertTimeout = setTimeout(later, wait);
        };
      }
      
      function updateConversionStatus(status, duration = null) {
        const footer = document.getElementById('conversion-footer');
        let text = `Latest conversion: ${status}`;
        if (duration !== null) {
          text += ` (${duration.toFixed(2)} ms)`;
        }
        const delayInput = footer.querySelector('label');
        footer.innerHTML = text;
        if (delayInput) {
          footer.appendChild(document.createTextNode(' | '));
          footer.appendChild(delayInput);
        }
      }

      function runConversion() {
        try {
          const templateString = templateEditor.getValue();
          const jsonString = inputEditor.getValue();

          if (!jsonString.trim()) {
            outputEditor.setValue('Input JSON is empty.');
            updateConversionStatus('No input');
            return;
          }
          
          const startTime = performance.now();
          const data = JSON.parse(jsonString);
          const template = Handlebars.compile(templateString);
          const resultHtml = template(data);
          const endTime = performance.now();
          const duration = endTime - startTime;
          
          outputEditor.setValue(resultHtml);
          updateConversionStatus('Success', duration);
        } catch (e) {
          outputEditor.setValue('Error: ' + e.message);
          updateConversionStatus('Error: ' + e.message);
        }
      }

      // Set up auto-convert button
      const autoConvertButton = document.getElementById('auto-convert-button');
      const autoConvertDelay = document.getElementById('auto-convert-delay');
      
      // Set initial active state
      autoConvertButton.classList.add('active');
      
      autoConvertButton.addEventListener('click', () => {
        autoConvertEnabled = !autoConvertEnabled;
        autoConvertButton.classList.toggle('active', autoConvertEnabled);
        if (autoConvertEnabled) {
          // Run once immediately when enabled
          runConversion();
        }
      });

      // Set up debounced conversion
      const debouncedConvert = () => {
        if (!autoConvertEnabled) return;
        const delay = parseInt(autoConvertDelay.value, 10) || 500;
        debounce(runConversion, delay)();
      };

      // Listen for changes in the template editor
      templateEditor.on('change', debouncedConvert);

      // Set up tree depth slider
      const treeDepthSlider = document.getElementById('tree-depth-slider');
      const depthValue = document.getElementById('depth-value');
      
      treeDepthSlider.addEventListener('input', () => {
        const value = parseInt(treeDepthSlider.value);
        const depth = value === 6 ? 0 : value; // 6 = infinite (0)
        depthValue.textContent = depth === 0 ? 'All' : depth;
        
        if (treeInstance) {
          treeInstance.options = treeInstance.options || {};
          treeInstance.options.closeDepth = depth;
          treeInstance.render(treeInstance.treeNodes);
          // Update visual states
          if (treeInstance.nodesById) {
            Object.values(treeInstance.nodesById).forEach(n => {
              try { treeInstance.updateLiElement && treeInstance.updateLiElement(n); } catch (err) { /* ignore */ }
            });
          }
        }
      });

      // Set up tree size slider
      const treeSizeSlider = document.getElementById('tree-size-slider');
      const sizeValue = document.getElementById('size-value');
      
      // Move ensureTreeWrapper to a higher scope
      const ensureTreeWrapper = () => {
        console.log('Ensuring tree wrapper...');
        const container = document.getElementById('json-tree-container');
        console.log('Container found:', container);
        if (container) {
          // Find the tree's ul element (the main nodes container)
          const treeUl = container.querySelector('.treejs-nodes');
          if (treeUl && !treeUl.closest('.tree-scale-wrapper')) {
            console.log('Creating new wrapper around tree nodes');
            const wrapper = document.createElement('div');
            wrapper.className = 'tree-scale-wrapper';
            // Wrap only the ul element
            treeUl.parentNode.insertBefore(wrapper, treeUl);
            wrapper.appendChild(treeUl);
            console.log('Wrapper created and populated');
          } else {
            console.log('Tree nodes or wrapper not found');
          }
        } else {
          console.log('Container not found');
        }
      };

      // Scale application function
      const applyTreeScale = (scale) => {
        const wrapper = document.getElementById('json-tree-container')
          ?.querySelector('.tree-scale-wrapper');
        if (wrapper) {
          console.log('Applying scale:', scale);
          wrapper.style.transform = `scale(${scale})`;
        }
      };

      let scaleTimeout = null;
      treeSizeSlider.addEventListener('input', () => {
        console.log('Size slider changed');
        const value = parseInt(treeSizeSlider.value);
        sizeValue.textContent = value + '%';
        const scale = value / 100;
        
        // Clear any pending timeout
        if (scaleTimeout) {
          clearTimeout(scaleTimeout);
        }
        
        // Apply scale immediately
        applyTreeScale(scale);
        
        // Track last scale that triggered a rerender
        treeSizeSlider.lastRenderScale = treeSizeSlider.lastRenderScale || 1;
        
        // Schedule a rerender if scale change is significant
        const scaleChange = Math.abs(scale - treeSizeSlider.lastRenderScale);
        if (scaleChange > 0.3 || scale <= 0.7) {
          scaleTimeout = setTimeout(() => {
            console.log(`Rerendering tree due to significant scale change (${scaleChange.toFixed(2)})`);
            if (treeInstance && treeInstance.treeNodes) {
              const currentScale = parseInt(treeSizeSlider.value) / 100;
              treeInstance.render(treeInstance.treeNodes);
              ensureTreeWrapper();
              // Wait a bit for the DOM to update before reapplying scale
              requestAnimationFrame(() => {
                applyTreeScale(currentScale);
                treeSizeSlider.lastRenderScale = currentScale;
              });
            }
          }, 500); // Wait for slider to settle
        }
      });

      // Set up column footers toggle
      const footersToggle = document.getElementById('toggle-column-footers');
      footersToggle.addEventListener('change', () => {
        document.body.classList.toggle('hide-column-footers', !footersToggle.checked);
      });

      // Setup undo/redo button handlers
      undoButton.onclick = () => {
        if (templateEditor.historySize().undo > 0) {
          templateEditor.undo();
          templateEditor.focus();
        }
      };
      redoButton.onclick = () => {
        if (templateEditor.historySize().redo > 0) {
          templateEditor.redo();
          templateEditor.focus();
        }
      };

      // Update button states based on history availability
      function updateButtonStates() {
        const history = templateEditor.historySize();
        undoButton.disabled = history.undo === 0;
        redoButton.disabled = history.redo === 0;
      }

      // Listen for changes to update button states
      templateEditor.on('change', updateButtonStates);
      updateButtonStates();

      // Setup copy button handler
      document.getElementById('copy-button').onclick = () => {
        const content = templateEditor.getValue();
        navigator.clipboard.writeText(content).then(() => {
          // Visual feedback using CSS class
          const copyButton = document.getElementById('copy-button');
          copyButton.classList.add('success');
          setTimeout(() => {
            copyButton.classList.remove('success');
          }, 1000);
        });
      };

      // Setup erase button handler
      eraseButton.onclick = () => {
        templateEditor.setValue('');
        templateEditor.focus();
      };

      // Setup download button handler
      const downloadButton = document.getElementById('download-button');
      downloadButton.onclick = () => {
        // Create filename with current date/time
        const now = new Date();
        const timestamp = now.toISOString()
          .replace(/:/g, '-')  // Replace colons with dashes
          .replace(/\./g, '-') // Replace dot with dash
          .replace(/T/, '_')   // Replace T with underscore
          .slice(0, -1);       // Remove the Z at the end
        const filename = `Kintegrate_${timestamp}.txt`;

        // Create blob and download link
        const content = templateEditor.getValue();
        const blob = new Blob([content], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        window.URL.revokeObjectURL(url);
      };

      // Setup upload button handler
      const uploadButton = document.getElementById('upload-button');
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.txt,.hbs,.handlebars';
      fileInput.style.display = 'none';
      document.body.appendChild(fileInput);

      uploadButton.onclick = () => {
        fileInput.click();
      };

      fileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            templateEditor.setValue(e.target.result);
            // Run conversion if auto-convert is enabled
            if (autoConvertEnabled) {
              runConversion();
            }
          };
          reader.readAsText(file);
        }
        // Reset file input so the same file can be selected again
        fileInput.value = '';
      };

      // Setup load examples button handler
      const loadExamplesButton = document.getElementById('load-examples-button');
      loadExamplesButton.onclick = async () => {
        try {
          // Fetch list of examples from the server
          const response = await fetch('example/conversion-scripts/');
          const html = await response.text();
          
          // Create temporary element to parse HTML and extract file links
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          const files = Array.from(doc.querySelectorAll('a'))
            .map(a => a.href)
            .filter(href => href.endsWith('.hbs') || href.endsWith('.handlebars') || href.endsWith('.txt'));

          // If no examples found, show message
          if (files.length === 0) {
            alert('No example templates found in example/conversion-scripts/');
            return;
          }

          // Create and show menu
          const menu = document.createElement('div');
          menu.className = 'kintegrate-context-menu';
          menu.style.position = 'fixed';
          menu.style.zIndex = '1000';
          menu.style.background = 'white';
          menu.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
          menu.style.border = '1px solid #ccc';
          menu.style.borderRadius = '4px';
          menu.style.padding = '4px 0';

          // Position menu above button
          const buttonRect = loadExamplesButton.getBoundingClientRect();
          menu.style.left = buttonRect.left + 'px';
          // First position it offscreen to get its height
          menu.style.top = '-1000px';
          document.body.appendChild(menu);
          const menuHeight = menu.offsetHeight;
          // Now position it above the button with 4px gap
          menu.style.top = (buttonRect.top - menuHeight - 4) + 'px';
          // If it would go off the top of the viewport, position it below the button instead
          if (buttonRect.top - menuHeight - 4 < 0) {
              menu.style.top = (buttonRect.bottom + 4) + 'px';
          }

          // Add menu items
          for (const file of files) {
            const fileName = file.split('/').pop();
            const item = document.createElement('div');
            item.className = 'kintegrate-context-option';
            item.textContent = fileName;
            item.style.padding = '4px 8px';
            item.style.cursor = 'pointer';
            item.style.whiteSpace = 'nowrap';
            
            item.onmouseover = () => {
              item.style.backgroundColor = '#f0f0f0';
            };
            item.onmouseout = () => {
              item.style.backgroundColor = '';
            };
            
            item.onclick = async () => {
              try {
                const response = await fetch(file);
                if (!response.ok) throw new Error('Failed to load example');
                const content = await response.text();
                templateEditor.setValue(content);
                if (autoConvertEnabled) {
                  runConversion();
                }
                menu.remove();
              } catch (error) {
                alert('Error loading example: ' + error.message);
                menu.remove();
              }
            };
            
            menu.appendChild(item);
          }

          // Add close option
          const closeItem = document.createElement('div');
          closeItem.className = 'kintegrate-context-option';
          closeItem.textContent = 'Cancel';
          closeItem.style.padding = '4px 8px';
          closeItem.style.cursor = 'pointer';
          closeItem.style.borderTop = '1px solid #ccc';
          closeItem.style.color = '#666';
          closeItem.onclick = () => menu.remove();
          menu.appendChild(closeItem);

          // Add menu to document
          document.body.appendChild(menu);

          // Close menu when clicking outside
          const closeMenu = (e) => {
            if (!menu.contains(e.target) && e.target !== loadExamplesButton) {
              menu.remove();
              document.removeEventListener('click', closeMenu);
            }
          };
          // Delay adding click listener to avoid immediate closure
          setTimeout(() => {
            document.addEventListener('click', closeMenu);
          });
        } catch (error) {
          alert('Error loading examples: ' + error.message);
        }
      };

      // Set up precompiled view functionality
      const showPrecompiledButton = document.getElementById('show-compiled');
      const precompiledTextarea = document.getElementById('precompiled-textarea');
      const precompiledButtons = document.getElementById('precompiled-buttons');
      const copyPrecompiledButton = document.getElementById('copy-precompiled-button');
      const closePrecompiledButton = document.getElementById('close-precompiled-button');

      let autoPrecompileEnabled = false;
      let precompileTimeout = null;

      function updatePrecompiledView() {
        const templateString = templateEditor.getValue();
        try {
          const compiled = Handlebars.precompile(templateString);
          precompiledTextarea.value = compiled;
        } catch (e) {
          precompiledTextarea.value = 'Error precompiling template: ' + e.message;
        }
      }

      function hidePrecompiledView() {
        precompiledTextarea.style.display = 'none';
        precompiledButtons.style.display = 'none';
        showPrecompiledButton.classList.remove('active');
        autoPrecompileEnabled = false;
      }

      function togglePrecompiledView() {
        autoPrecompileEnabled = !autoPrecompileEnabled;
        showPrecompiledButton.classList.toggle('active', autoPrecompileEnabled);
        
        if (autoPrecompileEnabled) {
          // Show the view and do initial update
          precompiledTextarea.style.display = 'block';
          precompiledButtons.style.display = 'flex';
          showPrecompiledButton.classList.add('active');
          updatePrecompiledView();
        } else {
          // Hide the view
          hidePrecompiledView();
          showPrecompiledButton.classList.remove('active');
        }
      }

      // Set up auto-update for precompiled view
      function debouncedPrecompileUpdate() {
        if (!autoPrecompileEnabled) return;
        const delay = parseInt(autoConvertDelay.value, 10) || 500;
        clearTimeout(precompileTimeout);
        precompileTimeout = setTimeout(updatePrecompiledView, delay);
      }

      // Listen for template changes to update precompiled view
      templateEditor.on('change', debouncedPrecompileUpdate);

      showPrecompiledButton.onclick = togglePrecompiledView;
      closePrecompiledButton.onclick = hidePrecompiledView;

      copyPrecompiledButton.onclick = () => {
        navigator.clipboard.writeText(precompiledTextarea.value).then(() => {
          // Visual feedback using CSS class
          copyPrecompiledButton.classList.add('success');
          setTimeout(() => {
            copyPrecompiledButton.classList.remove('success');
          }, 1000);
        });
      };
      const outputEditor = CodeMirror.fromTextArea(outputTextarea, { mode: 'application/json', lineNumbers: true, readOnly: true });
      const selectionListBox = document.getElementById('selection-list')
      const actions = document.getElementById('tree-actions');

      // small helper creating flat paths in Handlebars syntax
      function buildHandlebarsPath(pathArray, node) {
        if (!Array.isArray(pathArray)) return '';
        
        // Find the nearest context boundary ancestor
          function findNearestContextBoundary(currentNode) {
            if (!currentNode || !currentNode.path) return null;
            
            // First check if the current node itself is a boundary
            if (treeInstance.isContextBoundary(currentNode.id)) {
              return currentNode;
            }
            
            // Look up parent by ID instead of reconstructing from path
            let current = currentNode;
            while (current && current.parentId) {
              current = treeInstance.nodesById[current.parentId];
              if (current && treeInstance.isContextBoundary(current.id)) {
                return current;
              }            if (current && treeInstance.isContextBoundary(current.id)) {
              return current;
            }
          }
          return null;
        }
        
        // If we have a node, check for context boundary
        let processedPath = [...pathArray]; // Create a copy we can modify
        if (node) {
          const boundaryNode = findNearestContextBoundary(node);
          if (boundaryNode) {
            if (boundaryNode.id === node.id) {
              // If the node itself is the boundary, keep only what's after it
              processedPath = processedPath.slice(processedPath.length - 1);
            } else {
              // Trim path to start from boundary
              const boundaryDepth = boundaryNode.path.length;
              processedPath = processedPath.slice(boundaryDepth);
              
              // When there's a context boundary, we want to start with the first string segment
              // Find the index of the first string segment
              const firstStrIdx = processedPath.findIndex(p => typeof p === 'string');
              if (firstStrIdx > 0) {
                // Remove any leading numeric indices
                processedPath = processedPath.slice(firstStrIdx);
              }
            }
          }
        }
        
        // Convert path segments to Handlebars syntax
        return processedPath.map(p => {
          if (typeof p === 'number') return `[${p}]`; // Wrap array indices in square brackets
          if (/^[\p{L}_$][\p{L}\p{N}_$]*$/u.test(String(p))) return String(p);
          return `[${String(p).replace(/\\/g,'\\\\').replace(/]/g,'\\]')}]`;
        }).join('.');
      }

      // small helper creating tree-structs using {{#each ...}} or {{#with ...}} in Handlebars syntax based on a node deeper down in the structure
      function buildHandlebarsTree(node) {
        if (!node || !Array.isArray(node.path) || node.path.length === 0) return '';

        // Find the nearest context boundary ancestor
        function findNearestContextBoundary(currentNode) {
          if (!currentNode || !currentNode.path) return null;
          
          // First check if the current node itself is a boundary
          if (treeInstance.isContextBoundary(currentNode.id)) {
            return currentNode;
          }
          
          let current = currentNode;
          while (current) {
            // Get parent node by removing last element from path
            const parentPath = current.path.slice(0, -1);
            // Find node with this path including array indices
            current = Object.values(treeInstance.nodesById).find(
              n => n.path && n.path.length === parentPath.length && 
              n.path.every((v, i) => v === parentPath[i])
            );
            
            if (current && treeInstance.isContextBoundary(current.id)) {
              return current;
            }
          }
          return null;
        }

        // Get the context boundary ancestor if any
        const boundaryNode = findNearestContextBoundary(node);
        
        // If we have a context boundary, adjust the path appropriately
        let path;
        if (boundaryNode) {
          // Find array indices in the boundary path that we need to preserve
          const boundaryArrayIndices = boundaryNode.path
            .map((v, i) => typeof v === 'number' ? { index: i, value: v } : null)
            .filter(x => x !== null);
          
          if (boundaryNode.id === node.id) {f
            // If the node itself is the boundary, only use its last path segment
            path = [node.path[node.path.length - 1]];
          } else {
            // Otherwise trim path to start from boundary but preserve array indices
            path = node.path.slice(boundaryNode.path.length);
            
            // Insert necessary array indices from the boundary path
            boundaryArrayIndices.forEach(({ index, value }) => {
              if (index < boundaryNode.path.length) {
                // Insert array index at correct position relative to its parent
                const parentIndex = Math.max(0, index - 1);
                if (parentIndex < path.length) {
                  path.splice(parentIndex + 1, 0, value);
                }
              }
            });
          }
        } else {
          path = node.path;
        }

        let opens = [];
        let leaf = null;

        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          const next = path[i + 1];

          if (typeof p === 'number') {
            // numeric index is handled by the wrapper emitted for the previous property
            continue;
          }

          // If next is a number, this property is an array -> emit #each and skip the numeric index
          if (typeof next === 'number') {
            opens.push(`{{#each ${buildHandlebarsPath([p])}}}`);
            // skip the numeric index
            i++;
            continue;
          }

          // If there is another property after this, emit #with (object context)
          if (i < path.length - 1) {
            opens.push(`{{#with ${buildHandlebarsPath([p])}}}`);
            continue;
          }

          // Otherwise this is the leaf property
          leaf = buildHandlebarsPath([p]);
        }

        // If we still don't have a leaf (e.g. path ends in a number), pick last non-number segment
        if (!leaf) {
          for (let j = path.length - 1; j >= 0; j--) {
            if (typeof path[j] !== 'number') { leaf = buildHandlebarsPath([path[j]]); break; }
          }
        }

        // Build output with smarter nesting based on node type
        const lines = [];
        
        // For array nodes, modify the opens array to handle array properly
        if (node.nodeType === NODE_TYPE.ARRAY) {
            // Check if this is a specific array element by looking at the last path segment
            const isSpecificArrayElement = typeof path[path.length - 1] === 'number';
            
            // Remove any {{#each}} that might have been added for the array itself
            opens = opens.filter(o => !o.includes(leaf));
            
            // Add opening tags for parent contexts with indentation
            for (let idx = 0; idx < opens.length; idx++) {
                const indent = '  '.repeat(idx);
                lines.push(indent + opens[idx]);
            }

            // Add either with block for specific element or each block for whole array
            const indent = '  '.repeat(opens.length);
            if (leaf) {
                if (isSpecificArrayElement) {
                    // If a specific array element is selected, use {{#with}} and output the indexed value
                    const arrayPath = path.slice(0, -1);
                    const lastIndex = path[path.length - 1];
                    const arrayName = arrayPath.length > 0 ? buildHandlebarsPath(arrayPath) : leaf;
                    lines.push(indent + `{{#with ${arrayName}}}`);
                    lines.push(indent + `  {{[${lastIndex}]}}`);
                    lines.push(indent + '{{/with}}');
                } else {
                    // For the whole array, use {{#each}}
                    lines.push(indent + `{{#each ${leaf}}}`);
                    lines.push(indent + '  {{.}}');
                    lines.push(indent + '{{/each}}');
                }
            }
        } else {
            // Handle non-array nodes (objects and primitives)
            // Add opening tags with indentation (outer -> inner)
            for (let idx = 0; idx < opens.length; idx++) {
                const indent = '  '.repeat(idx);
                lines.push(indent + opens[idx]);
            }

            // Add inner content based on node type
            const indent = '  '.repeat(opens.length);
            if (node.nodeType === NODE_TYPE.OBJECT && leaf) {
                // For objects, add {{#with}} to access properties
                lines.push(indent + `{{#with ${leaf}}}`);
                lines.push(indent + '  {{.}}');
                lines.push(indent + '{{/with}}');
            } else if (node.nodeType === NODE_TYPE.ARRAY) {
                // Check if this is a specific array element
                const lastPathSegment = path[path.length - 1];
                const isSpecificArrayElement = typeof lastPathSegment === 'number';
                
                if (isSpecificArrayElement) {
                    // For specific array element, use {{#with}} and the index
                    const arrayPath = path.slice(0, -1);
                    const arrayName = arrayPath.map(p => typeof p === 'string' ? p : `[${p}]`).join('.');
                    lines.push(indent + `{{#with ${arrayName}}}`);
                    lines.push(indent + `  {{[${lastPathSegment}]}}`);
                    lines.push(indent + '{{/with}}');
                } else {
                    // For whole array, use {{#each}}
                    lines.push(indent + `{{#each ${leaf}}}`);
                    lines.push(indent + '  {{.}}');
                    lines.push(indent + '{{/each}}');
                }
            } else if (leaf) {
                // For primitives, just output the leaf value
                lines.push(indent + '{{' + leaf + '}}');
            }
        }

        // Add closing tags with matching indentation (inner -> outer)
        for (let k = opens.length - 1; k >= 0; k--) {
            const openTag = opens[k];
            const m = openTag.match(/^\{\{#(each|with)\s+/);
            const tag = m ? m[1] : 'with';
            const indent = '  '.repeat(k);
            lines.push(indent + `{{/${tag}}}`);
        }

        return lines.join('\n');
      }

      // Use the provided Tree widget (tree.min.js) for rendering and selection.
      const jsonTreeContainer = document.getElementById('json-tree-container');
      let treeInstance = null;

      // Node type constants
      const NODE_TYPE = {
        PRIMITIVE: 'primitive',
        ARRAY: 'array',
        OBJECT: 'object'
      };

      // Convert arbitrary JSON into the tree widget's expected node format.
      let _idCounter = 1;
      function nextId() { return 'n' + (_idCounter++); }

      // Create a node with common properties
      function createNode(id, text, path, nodeType, parent = null, children = undefined) {
        // Store parent ID instead of direct reference to avoid circular structure
        const parentId = parent ? parent.id : null;
        return {
          id,
          text,
          path,
          nodeType,
          parentId, // Store parent ID instead of direct reference
          children  // undefined for leaf nodes
        };
      }

      // Recursive function to convert JSON to tree nodes with cleaner array handling
      function jsTreeNodes(value, path = [], parent = null) {
        const type = Object.prototype.toString.call(value);

        // Handle plain objects
        if (type === '[object Object]') {
          const nodes = [];
          for (const key of Object.keys(value)) {
            const val = value[key];
            const basePath = path.concat(key);
            const nodeId = nextId();

            // Handle the value
            const valType = Object.prototype.toString.call(val);
            if (valType === '[object Object]') {
              // Object value
              const objNode = createNode(nodeId, key, basePath, NODE_TYPE.OBJECT, parent);
              const children = jsTreeNodes(val, basePath, objNode);
              if (children.length) objNode.children = children;
              nodes.push(objNode);
            } else if (Array.isArray(val)) {
              // Array value - use key as node text with array type indicator
              const arrayNode = createNode(nodeId, key, basePath, NODE_TYPE.ARRAY, parent);
              const children = val.map((item, i) => {
                const itemPath = basePath.concat(i);
                const itemId = nextId();
                const itemType = Object.prototype.toString.call(item);

                if (itemType === '[object Object]' || Array.isArray(item)) {
                  // Complex item (object/array)
                  const itemNode = createNode(
                    itemId,
                    Array.isArray(item) ? `[${i}]` : i.toString(),
                    itemPath,
                    Array.isArray(item) ? NODE_TYPE.ARRAY : NODE_TYPE.OBJECT,
                    arrayNode
                  );
                  const itemChildren = jsTreeNodes(item, itemPath, itemNode);
                  if (itemChildren.length) itemNode.children = itemChildren;
                  return itemNode;
                } else {
                  // Primitive item
                  return createNode(itemId, String(item), itemPath, NODE_TYPE.PRIMITIVE, arrayNode);
                }
              });
              
              if (children.length) arrayNode.children = children;
              nodes.push(arrayNode);
            } else {
              // Primitive value
              nodes.push(createNode(nodeId, `${key} = ${String(val)}`, basePath, NODE_TYPE.PRIMITIVE, parent));
            }
          }
          return nodes;
        }

        // Handle arrays (top level)
        if (Array.isArray(value)) {
          return value.map((item, i) => {
            const nodePath = path.concat(i);
            const nodeId = nextId();
            const itemType = Object.prototype.toString.call(item);

            if (itemType === '[object Object]' || Array.isArray(item)) {
              // Complex item (object/array)
              const node = createNode(
                nodeId,
                `[${i}]`,
                nodePath,
                Array.isArray(item) ? NODE_TYPE.ARRAY : NODE_TYPE.OBJECT,
                parent
              );
              const children = jsTreeNodes(item, nodePath, node);
              if (children.length) node.children = children;
              return node;
            } else {
              // Primitive item
              return createNode(nodeId, String(item), nodePath, NODE_TYPE.PRIMITIVE, parent);
            }
          });
        }

        // Primitive value
        return [createNode(nextId(), String(value), path, NODE_TYPE.PRIMITIVE, parent)];

      }

      function insertPathsFromNodes(nodes) {
        if (!nodes || nodes.length === 0) return;
        const inserts = nodes.map(n => `{{${buildHandlebarsPath(n.path)}}}`);
        templateEditor.replaceSelection(inserts.join('\n'));
        templateEditor.focus();
      }

      // Render the selected paths list. Accepts an array of node objects (deepest selected nodes).
      function renderSelectedPaths(nodes) {
        const selectedListEl = document.getElementById('selected-paths');
        if (!selectedListEl) return;

        // show/hide actions area and paths list depending on selection
        const actionsWrap = document.querySelector('.tree-actions');
        if (!nodes || nodes.length === 0) {
          if (actionsWrap) actionsWrap.style.display = 'none';
          selectedListEl.style.display = 'none';
          return;
        }

        // Show the containers since we have selections
        if (actionsWrap) actionsWrap.style.display = 'inline-block';
        selectedListEl.style.display = 'block';

        const ul = document.createElement('ul');
        for (const n of nodes) {
          const li = document.createElement('li');

          // Tree structure generator button at start of row
          const treeIconBtn = document.createElement('button');
          treeIconBtn.type = 'button';
          treeIconBtn.className = 'path-icon';
          treeIconBtn.title = 'Selected path';
          treeIconBtn.style.border = '1px solid';
          treeIconBtn.style.background = 'transparent';
          treeIconBtn.style.padding = '3px';
          treeIconBtn.style.cursor = 'pointer';
          treeIconBtn.innerHTML = '‚§°';
          treeIconBtn.addEventListener('click', () => {
            // For array elements, use direct template generation
            if (n.nodeType === NODE_TYPE.PRIMITIVE && typeof n.path[n.path.length - 1] === 'number') {
              // Get the array path (everything before the numeric index)
              const arrayPath = n.path.slice(0, -1);
              const lastIndex = n.path[n.path.length - 1];
              
              // Build the template with proper nesting and index access
              let template = arrayPath.reduce((acc, pathSegment, i) => {
                if (typeof pathSegment === 'string') {
                  return acc + `{{#with ${pathSegment}}}\n  ` + '  '.repeat(i);
                }
                return acc;
              }, '');
              
              template += `{{[${lastIndex}]}}`;
              
              // Add closing tags
              const closingTags = arrayPath.filter(p => typeof p === 'string')
                .map((_, i) => '  '.repeat(arrayPath.length - i - 2) + '{{/with}}')
                .reverse()
                .join('\n');
              
              if (closingTags) {
                template += '\n' + closingTags;
              }
              
              templateEditor.replaceSelection(template);
            } else {
              templateEditor.replaceSelection(buildHandlebarsTree(n));
            }
            templateEditor.focus();
          });
          li.appendChild(treeIconBtn);

          // Flat path button at second position of row
          const flatPathBtn = document.createElement('button');
          flatPathBtn.type = 'button';
          flatPathBtn.textContent = "‚Üî "+buildHandlebarsPath(n.path);
          flatPathBtn.style.cursor = 'pointer';
          flatPathBtn.style.border = '1px solid'
          flatPathBtn.addEventListener('click', () => {
            templateEditor.replaceSelection(`{{${buildHandlebarsPath(n.path)}}}`);
            templateEditor.focus();
          });
          li.appendChild(flatPathBtn);

          ul.appendChild(li);
        }

  // show actions area when we have selections
  const actionsWrap2 = document.querySelector('.tree-actions');
  if (actionsWrap2) actionsWrap2.style.display = '';

  selectedListEl.innerHTML = '';
  selectedListEl.appendChild(ul);
      }

      function updateJsonTree(jsonString) {
        try {
          const jsonData = JSON.parse(jsonString);
          _idCounter = 1;
          const treeData = jsTreeNodes(jsonData, []);
          
          // Clear the container before adding new content
          jsonTreeContainer.innerHTML = '';

          // Set up insert button click handler
          const insertButton = document.getElementById('insert-selected-paths');
          if (insertButton) {
            insertButton.onclick = () => {
              if (!treeInstance) return;
              const selected = treeInstance.selectedNodes || [];
              const selectedNodes = selected.filter(n => n && n.status === 2 && Array.isArray(n.path));
              if (selectedNodes.length > 0) {
                insertPathsFromNodes(selectedNodes);
              }
            };
          }

          // Initialize Tree widget into our container
          const selector = '#json-tree-container';
          let initialTreeDepth = 0;
          const treeDepthControl = document.getElementById('tree-depth-slider');
          if (treeDepthControl) {
            const sliderValue = parseInt(treeDepthControl.value);
            initialTreeDepth = sliderValue === 6 ? 0 : sliderValue;
          }
          
          // Clear node path lookup before initializing tree
          jsTreeNodes.nodesByPath = new Map();
          
          // Note: ensureTreeWrapper is now defined in a higher scope

          // Initialize tree with our extended version that includes context boundary support
          treeInstance = new ExtendedTree(selector, {
            data: treeData,
            closeDepth: initialTreeDepth,
            onCreateLi: function(node, li) {
              // Add node type classes during rendering
              if (node.nodeType) {
                li.classList.add('node-' + node.nodeType);
              }
              // Ensure wrapper exists after tree renders
              ensureTreeWrapper();
            },
            
            // Add node type classes during rendering
            onCreateLi: function(node, li) {
              if (node.nodeType) {
                li.classList.add('node-' + node.nodeType);
              }
            },

            onChange: function() {
              const selected = this.selectedNodes || [];
              const insertButton = document.getElementById('insert-selected-paths');
              
              // Show/hide insert button based on selection
              if (insertButton) {
                insertButton.style.display = selected.some(n => n && n.status === 2) ? '' : 'none';
              }
            } // end of onChange
          });

          // ****************************
          // Right-click on a node: toggle that node only (don't cascade to descendants)
          // This preserves children selection states but updates ancestor statuses.
          
          // Right-click on a node: show context menu with options
          jsonTreeContainer.addEventListener('contextmenu', (ev) => {
              if (!treeInstance) return;
              ev.preventDefault();
              
              // Find clicked element
              let el = ev.target;
              while (el && el !== jsonTreeContainer) {
                  if (el.tagName === 'LI' && el.classList.contains('treejs-node')) break;
                  el = el.parentElement;
              }
              
              // Exit if no valid tree node found
              if (!el || el === jsonTreeContainer) return;
              
              // Get node data from the tree widget
              const nodeId = el.nodeId;
              if (!nodeId || !treeInstance.nodesById) return;
              
              const node = treeInstance.nodesById[nodeId];
              if (!node) return;
              
              // Remove any existing menus
              const existingMenu = document.querySelector('.kintegrate-context-menu');
              if (existingMenu) {
                  existingMenu.parentNode.removeChild(existingMenu);
              }
              
              // Create and position the context menu
              const menu = document.createElement('div');
              menu.className = 'kintegrate-context-menu';
              menu.style.position = 'fixed';  // Changed from 'absolute' to 'fixed'
              menu.style.left = ev.clientX + 'px';  // Use clientX instead of pageX
              menu.style.top = ev.clientY + 'px';   // Use clientY instead of pageY
              menu.style.zIndex = '1000';

              // Add menu options
              const flatPathOption = document.createElement('div'); 
              flatPathOption.className = 'kintegrate-context-option';
              flatPathOption.textContent = '‚Üî Insert flat path: ' + buildHandlebarsPath(node.path, node);
              flatPathOption.addEventListener('click', () => {
                  templateEditor.replaceSelection(`{{${buildHandlebarsPath(node.path, node)}}}`);
                  templateEditor.focus();
                  menu.remove();
              });
              menu.appendChild(flatPathOption);

              const treeStructOption = document.createElement('div');  
              treeStructOption.className = 'kintegrate-context-option';
              treeStructOption.textContent = '‚§° Insert tree structure';
              treeStructOption.addEventListener('click', () => {
                  const treeStr = buildHandlebarsTree(node);
                  if (treeStr) {
                      templateEditor.replaceSelection(treeStr);
                      templateEditor.focus();
                  }
                  menu.remove();
              });
              menu.appendChild(treeStructOption);

              // Add context boundary option
              const contextBoundaryOption = document.createElement('div');
              contextBoundaryOption.className = 'kintegrate-context-option';
              const isCurrentlyBoundary = treeInstance.isContextBoundary(nodeId);
              contextBoundaryOption.textContent = (isCurrentlyBoundary ? '‚úì Remove' : '‚¨ö‚àö Set') + ' as context boundary';
              contextBoundaryOption.addEventListener('click', () => {
                  const newState = !treeInstance.isContextBoundary(nodeId);
                  treeInstance.setContextBoundary(nodeId, newState);
                  el.classList.toggle('context-boundary', newState);
                  menu.remove();
              });
              menu.appendChild(contextBoundaryOption);
              
              // Add the menu to the document
              document.body.appendChild(menu);

              // Ensure menu is visible within viewport
              const menuRect = menu.getBoundingClientRect();
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              
              if (menuRect.right > viewportWidth) {
                  menu.style.left = (viewportWidth - menuRect.width - 10) + 'px';
              }
              if (menuRect.bottom > viewportHeight) {
                  menu.style.top = (viewportHeight - menuRect.height - 10) + 'px';
              }

              // Handle menu removal
              const removeMenu = () => {
                  if (menu && menu.parentNode) {
                      menu.parentNode.removeChild(menu);
                  }
                  document.removeEventListener('click', removeMenu);
                  document.removeEventListener('mousemove', trackMouse);
              };

              // Track mouse movement
              const trackMouse = (e) => {
                  if (!menu) return;
                  const rect = menu.getBoundingClientRect();
                  const buffer = 10; // 10px buffer zone
                  
                  if (e.clientX < rect.left - buffer || 
                      e.clientX > rect.right + buffer || 
                      e.clientY < rect.top - buffer || 
                      e.clientY > rect.bottom + buffer) {
                      removeMenu();
                  }
              };

              // Set up event listeners for menu removal
              document.addEventListener('click', removeMenu);
              document.addEventListener('mousemove', trackMouse);
          });
          //***************************

          // Update tree depth slider display
          if (treeDepthControl && document.getElementById('depth-value')) {
            const value = parseInt(treeDepthControl.value);
            const depth = value === 6 ? 0 : value;
            document.getElementById('depth-value').textContent = depth === 0 ? 'All' : depth;
          }

          console.log('Tree rendering complete, checking wrapper...');
          // Ensure wrapper exists after tree is rendered
          setTimeout(() => {
            console.log('Delayed wrapper check...');
            ensureTreeWrapper();
          }, 100);

          // Initialize the tree size slider
          const treeSizeSlider = document.getElementById('tree-size-slider');
          const sizeValue = document.getElementById('size-value');
          if (treeSizeSlider && sizeValue) {
            const value = parseInt(treeSizeSlider.value);
            sizeValue.textContent = value + '%';
            const treeContainer = document.getElementById('json-tree-container');
            if (treeContainer) {
              const wrapper = treeContainer.querySelector('.tree-scale-wrapper');
              if (wrapper) {
                const scale = value / 100;
                wrapper.style.transform = `scale(${scale})`;
              }
            }
          }

          } catch (e) {
            // Display error in the tree container
            jsonTreeContainer.innerHTML = `
              <div style="color: red; padding: 10px; border: 1px solid red; margin: 10px; background-color: #fff0f0;">
                <strong>Invalid JSON</strong><br>
                <pre style="margin-top: 8px; white-space: pre-wrap;">${e.message}</pre>
              </div>`;
            
            // Also update the selected paths area to show no selection
            const selectedPaths = document.getElementById('selected-paths');
            if (selectedPaths) {
              selectedPaths.innerHTML = 'No nodes selected. (Fix JSON syntax error to enable selection)';
            }
            
            // Hide the actions area since we can't select anything
            const actionsWrap = document.querySelector('.tree-actions');
            if (actionsWrap) {
              actionsWrap.style.display = 'none';
            }
          }
      }

      function insertSelectedPathsAtCursor() {
        if (!selectedPaths || selectedPaths.length === 0) return;
        const inserts = selectedPaths.map(p => `{{${buildHandlebarsPath(p)}}}`);
        templateEditor.replaceSelection(inserts.join('\n'));
        templateEditor.focus();
      };
      
      // Load intro.json by default
      fetch('example/instance/intro.json')
        .then(response => response.ok ? response.text() : Promise.reject('Network response was not ok'))
        .then(data => {
          inputEditor.setValue(data);
          updateJsonTree(data);
          // Run initial conversion since auto-convert is enabled by default
          runConversion();
        })
        .catch(error => {
          console.error('Error loading intro.json:', error);
          // Fallback to empty JSON if file can't be loaded
          inputEditor.setValue('{}');
          // Run initial conversion even with empty data
          runConversion();
        });
      outputEditor.setValue('Output goes here after conversion is run.');

      // --- Event Handlers ---
      // We use auto-convert now, no manual conversion button needed

      // File input handling
      document.getElementById('fileInput').addEventListener('change', function(ev) {
        const file = ev.target.files && ev.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const content = e.target.result;
            inputEditor.setValue(content);
            updateJsonTree(content);
            // Run conversion immediately if auto-convert is enabled
            if (autoConvertEnabled) {
              runConversion();
            }
          };
          reader.readAsText(file);
        }
      });

      // Bookmark management system
      class BookmarkManager {
        constructor(options) {
          this.options = {
            buttonId: options.buttonId,
            storageKey: options.storageKey,
            title: options.title,
            onLoad: options.onLoad,
            defaultPath: options.defaultPath || '',
            fileFilter: options.fileFilter || (() => true),
            menuPosition: options.menuPosition || 'up' // 'up' or 'down'
          };
          
          // Load bookmarks from localStorage
          this.bookmarks = JSON.parse(localStorage.getItem(this.options.storageKey) || '[]');
          
          // Setup button click handler
          const button = document.getElementById(this.options.buttonId);
          if (button) {
            button.onclick = () => this.showMenu();
          }
        }

        async showMenu() {
          const button = document.getElementById(this.options.buttonId);
          if (!button) return;

          try {
            // Create menu wrapper
            const menu = document.createElement('div');
            menu.className = 'kintegrate-context-menu';
            menu.style.position = 'fixed';
            menu.style.zIndex = '1000';
            menu.style.background = 'white';
            menu.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            menu.style.border = '1px solid #ccc';
            menu.style.borderRadius = '4px';
            menu.style.padding = '4px 0';
            menu.style.minWidth = '250px';
            menu.style.maxWidth = '400px';

            // Add close button at the top right
            const closeButton = document.createElement('button');
            closeButton.style.position = 'sticky';
            closeButton.style.float = 'right';
            closeButton.style.margin = '4px';
            closeButton.style.border = 'none';
            closeButton.style.background = 'none';
            closeButton.style.padding = '4px';
            closeButton.style.cursor = 'pointer';
            closeButton.style.opacity = '0.6';
            closeButton.style.zIndex = '2';
            closeButton.title = 'Close menu';
            closeButton.innerHTML = '<svg focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width: 16px; height: 16px;"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>';
            closeButton.onmouseover = () => closeButton.style.opacity = '1';
            closeButton.onmouseout = () => closeButton.style.opacity = '0.6';
            closeButton.onclick = () => menu.remove();
            menu.appendChild(closeButton);

            // Add bookmarks section if any exist
            if (this.bookmarks.length > 0) {
              const bookmarksHeader = document.createElement('div');
              bookmarksHeader.style.padding = '4px 8px';
              bookmarksHeader.style.color = '#666';
              bookmarksHeader.style.fontSize = '0.8em';
              bookmarksHeader.textContent = 'Bookmarks';
              menu.appendChild(bookmarksHeader);

              const bookmarkList = document.createElement('ul');
              bookmarkList.style.margin = '0';
              bookmarkList.style.padding = '0';
              bookmarkList.style.listStyle = 'none';

              for (const bookmark of this.bookmarks) {
                const li = document.createElement('li');
                li.style.padding = '4px 8px';
                li.style.cursor = 'pointer';
                li.style.display = 'flex';
                li.style.justifyContent = 'space-between';
                li.style.alignItems = 'center';
                li.title = bookmark.path; // Show full path on hover

                const textSpan = document.createElement('span');
                textSpan.textContent = bookmark.name;
                textSpan.style.overflow = 'hidden';
                textSpan.style.textOverflow = 'ellipsis';
                textSpan.style.whiteSpace = 'nowrap';
                li.appendChild(textSpan);

                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '<svg focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width: 20px; height: 20px;"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>';
                deleteBtn.style.border = 'none';
                deleteBtn.style.background = 'none';
                deleteBtn.style.padding = '2px';
                deleteBtn.style.marginLeft = '8px';
                deleteBtn.style.cursor = 'pointer';
                deleteBtn.style.opacity = '0';
                deleteBtn.title = 'Remove bookmark';

                li.onmouseover = () => {
                  li.style.backgroundColor = '#f0f0f0';
                  deleteBtn.style.opacity = '1';
                };
                li.onmouseout = () => {
                  li.style.backgroundColor = '';
                  deleteBtn.style.opacity = '0';
                };

                deleteBtn.onclick = (e) => {
                  e.stopPropagation();
                  this.removeBookmark(bookmark.name);
                  li.remove();
                  if (bookmarkList.children.length === 0) {
                    menu.remove();
                  }
                };

                li.onclick = async () => {
                  try {
                    const response = await fetch(bookmark.path);
                    if (!response.ok) throw new Error('Failed to load bookmark');
                    const content = await response.text();
                    this.options.onLoad(content);
                    menu.remove();
                  } catch (error) {
                    alert('Error loading bookmark: ' + error.message);
                  }
                };

                li.appendChild(deleteBtn);
                bookmarkList.appendChild(li);
              }

              menu.appendChild(bookmarkList);
              menu.appendChild(document.createElement('hr'));
            }

            // Add bookmark from URL section
            const addUrlSection = document.createElement('div');
            addUrlSection.style.padding = '4px 8px';

            const urlInput = document.createElement('input');
            urlInput.type = 'text';
            urlInput.placeholder = 'Enter URL to bookmark...';
            urlInput.style.width = '100%';
            urlInput.style.padding = '4px';
            urlInput.style.marginBottom = '4px';
            urlInput.style.boxSizing = 'border-box';

            const addButton = document.createElement('button');
            addButton.textContent = 'Add Bookmark';
            addButton.style.width = '100%';
            addButton.style.padding = '4px';
            addButton.style.marginBottom = '8px';

            addButton.onclick = async () => {
              const url = urlInput.value.trim();
              if (!url) return;

              try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to load URL');
                const content = await response.text();
                
                const fileName = url.split('/').pop() || url;
                this.addBookmark(fileName, url);
                this.options.onLoad(content);
                menu.remove();
              } catch (error) {
                alert('Error adding bookmark: ' + error.message);
              }
            };

            addUrlSection.appendChild(urlInput);
            addUrlSection.appendChild(addButton);
            menu.appendChild(addUrlSection);

            // Add "Browse server" option
            this.addMenuItem(menu, 'Example from this server...', async () => {
              try {
                const response = await fetch(this.options.defaultPath);
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const files = Array.from(doc.querySelectorAll('a'))
                  .map(a => a.href)
                  .filter(this.options.fileFilter);

                if (files.length === 0) {
                  alert('No files found in ' + this.options.defaultPath);
                  return;
                }

                // Replace current menu items with file list
                menu.innerHTML = '';
                const browserHeader = document.createElement('div');
                browserHeader.style.padding = '4px 8px';
                browserHeader.style.color = '#666';
                browserHeader.style.fontSize = '0.8em';
                browserHeader.textContent = 'Server files';
                menu.appendChild(browserHeader);

                const fileList = document.createElement('ul');
                fileList.style.margin = '0';
                fileList.style.padding = '0';
                fileList.style.listStyle = 'none';

                for (const file of files) {
                  const fileName = file.split('/').pop();
                  const li = document.createElement('li');
                  li.style.padding = '4px 8px';
                  li.style.cursor = 'pointer';
                  li.textContent = fileName;
                  li.title = file; // Show full path on hover

                  li.onmouseover = () => li.style.backgroundColor = '#f0f0f0';
                  li.onmouseout = () => li.style.backgroundColor = '';
                  
                  li.onclick = async () => {
                    try {
                      const response = await fetch(file);
                      if (!response.ok) throw new Error('Failed to load file');
                      const content = await response.text();
                      this.options.onLoad(content);

                      // Add to bookmarks if not already present
                      if (!this.bookmarks.some(b => b.path === file)) {
                        this.addBookmark(fileName, file);
                      }
                      
                      menu.remove();
                    } catch (error) {
                      alert('Error loading file: ' + error.message);
                    }
                  };

                  fileList.appendChild(li);
                }

                menu.appendChild(fileList);
                menu.appendChild(document.createElement('hr'));
              } catch (error) {
                alert('Error browsing server: ' + error.message);
              }
            });

            // Position menu
            const buttonRect = button.getBoundingClientRect();
            menu.style.left = buttonRect.left + 'px';

            // First position it offscreen to get its height
            menu.style.top = '-1000px';
            document.body.appendChild(menu);
            const menuHeight = menu.offsetHeight;

            // Position based on option
            if (this.options.menuPosition === 'up') {
              menu.style.top = (buttonRect.top - menuHeight - 4) + 'px';
              // Fall back to down if it would go off screen
              if (buttonRect.top - menuHeight - 4 < 0) {
                menu.style.top = (buttonRect.bottom + 4) + 'px';
              }
            } else {
              menu.style.top = (buttonRect.bottom + 4) + 'px';
            }

            // Close menu when clicking outside
            const closeMenu = (e) => {
              if (!menu.contains(e.target) && e.target !== button) {
                menu.remove();
                document.removeEventListener('click', closeMenu);
              }
            };
            setTimeout(() => document.addEventListener('click', closeMenu));

          } catch (error) {
            alert('Error showing menu: ' + error.message);
          }
        }

        addMenuItem(menu, text, onClick) {
          const item = document.createElement('div');
          item.className = 'kintegrate-context-option';
          item.style.padding = '4px 8px';
          item.style.cursor = 'pointer';
          
          const textSpan = document.createElement('span');
          textSpan.textContent = text;
          item.appendChild(textSpan);

          item.onmouseover = () => item.style.backgroundColor = '#f0f0f0';
          item.onmouseout = () => item.style.backgroundColor = '';
          item.onclick = onClick;

          menu.appendChild(item);
        }

        addBookmark(name, path) {
          if (!this.bookmarks.some(b => b.path === path)) {
            this.bookmarks.push({ name, path });
            localStorage.setItem(this.options.storageKey, JSON.stringify(this.bookmarks));
          }
        }

        removeBookmark(name) {
          this.bookmarks = this.bookmarks.filter(b => b.name !== name);
          localStorage.setItem(this.options.storageKey, JSON.stringify(this.bookmarks));
        }
      }

      // Initialize bookmark managers for input data and conversion scripts
      const inputBookmarks = new BookmarkManager({
        buttonId: 'example-select',
        storageKey: 'kintegrate-input-bookmarks',
        title: 'Input Data',
        defaultPath: 'example/instance/',
        fileFilter: href => href.endsWith('.json'),
        onLoad: (content) => {
          inputEditor.setValue(content);
          updateJsonTree(content);
          if (autoConvertEnabled) {
            runConversion();
          }
        },
        menuPosition: 'down'
      });

      const scriptBookmarks = new BookmarkManager({
        buttonId: 'load-examples-button',
        storageKey: 'kintegrate-script-bookmarks',
        title: 'Conversion Scripts',
        defaultPath: 'src/example/conversion-scripts/',
        fileFilter: href => href.endsWith('.hbs') || href.endsWith('.handlebars'),
        onLoad: (content) => {
          templateEditor.setValue(content);
          if (autoConvertEnabled) {
            runConversion();
          }
        },
        menuPosition: 'up'
      });

      document.getElementById('toggle-line-numbers').addEventListener('change', function() {
        const showLineNumbers = this.checked;
        const editors = [inputEditor, templateEditor, outputEditor];
        editors.forEach(editor => editor.setOption('lineNumbers', showLineNumbers));
      });

      // Update tree and run conversion when user types in the input editor
      inputEditor.on('change', (editor) => {
        updateJsonTree(editor.getValue());
        // Run auto-convert if enabled
        if (autoConvertEnabled) {
          const delay = parseInt(autoConvertDelay.value, 10) || 500;
          debounce(runConversion, delay)();
        }
      });

      // ============================================
      // Form Viewer Button Wiring
      // ============================================
      document.getElementById('open-form-viewer-btn')?.addEventListener('click', openFormViewer);
      
      // Phase 2: Wire up composition handling buttons
      document.getElementById('push-to-form-btn')?.addEventListener('click', () => pushToForm(inputEditor));
      document.getElementById('pull-from-form-btn')?.addEventListener('click', pullFromForm);
      
      // Phase 4: Wire up sync mode button
      document.getElementById('sync-mode-btn')?.addEventListener('click', toggleSyncMode);
      
      // Download button - needs access to inputEditor
      document.getElementById('download-instance-btn')?.addEventListener('click', () => {
      document.getElementById('download-instance-btn')?.addEventListener('click', () => {
        const content = inputEditor ? inputEditor.getValue() : 
                        document.getElementById('inputInstance').value;
        
        if (!content || content.trim() === '') {
          alert('No instance data to download');
          return;
        }
        
        // Generate filename with timestamp
        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
        const filename = `composition-${timestamp}.json`;
        
        // Create download
        const blob = new Blob([content], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
        console.log('[Main] Downloaded instance as:', filename);
      });
      
      // Override updateInputFromComposition with access to inputEditor
      updateInputFromComposition = (composition) => {
        if (!composition) {
          console.log('[Main] No composition data received');
          return;
        }
        
        const jsonStr = JSON.stringify(composition, null, 2);
        
        // Update input editor
        if (inputEditor) {
          inputEditor.setValue(jsonStr);
        } else {
          document.getElementById('inputInstance').value = jsonStr;
        }
        
        // The existing inputEditor.on('change') handler will trigger:
        // - updateJsonTree()
        // - runConversion() if autoConvertEnabled
        
        console.log('[Main] Input updated from composition');
      };

      }); // DOMContentLoaded
    </script>
  </body>
</html>
