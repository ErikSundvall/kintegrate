<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Kintegrate</title>
    <link rel="stylesheet" href="resizable-columns.css">
    <!--  css for tree widget -->
    <link rel="stylesheet" href="tree.min.css">
    <!-- CodeMirror 5 CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">


  </head>
  <body>
    <!--header>
      <p>K!ntegrate</p>
    </header -->
    <main>
      <div class="fullheight-container" id="main-container">
        <div id="input-container" class="column column-left">
            <!-- file picker that can pick files from user upload -->
            Pick example file <input type="file" id="fileInput" accept=".json,.xml,.txt"><br>
            or select example:
            <!-- Dropdown that can load any existing file in web server side subdirectory /example/instance into the textarea that has id="inputInstance"  -->
            <select id="exampleSelect">
              <option value="">--Select an example--</option>
              <option value="MDK_Rek_demo1.json">MDK_Rek_demo1.json</option>
              <option value="mdk_lunga_1.json">mdk_lunga_1.json</option>
              <option value="non_existing_example.json">non_existing_example.json</option>
            </select><br>
            or just paste input into the box below<br>
            <textarea id="inputInstance">Input example goes here</textarea>
            <hr>
            <div id="json-tree-container">Parsed input from above goes here into a foldable tree. The tree-branches can then be clicked to get paths that can be used in conversion template</div>
        </div>
        <div class="resizer"></div>
        <div id="conversion-container" class="column column-center">
            <h2>Conversion Template (Handlebars)</h2>
            <textarea id="template-editor">
{{!-- 
  This is the column where you author (and possibly compile) your conversion script.
  Currently you see a simple Handlebars template.
  After importing instance data and/or schema (or other structure defitnitions) they can help you author the conversion script.
  Select nodes in the tree on the left to insert paths to data elements at the current cursor position in this template.
  
  Example: {{granskning.bakgrund.0.sjukdomshistoria.0.ospecificerad_händelse.0.anamnes.0.['|value']}}
--}}
Språk: {{ctx.language}}
Land: {{ctx.territory}} 

            </textarea>
        <button id="run-conversion">Run Conversion --- > Output</button>
        <button id="show-compiled">Show precompiled template</button>
      </div>
        <div class="resizer"></div>
        <div id="output-container" class="column column-right">
            <textarea id="out">Output goes here after conversion is run</textarea>
        </div>
      </div>
      <footer>
          <strong>K!ntegrate</strong> v0.1 A rudimentary integration tool with roots at <strong><a href="https://www.karolinskahospital.com/">K</a></a></strong>. Settings:
          <label style="cursor: pointer;">
            <input type="checkbox" id="toggle-line-numbers" checked> Show line numbers
          </label>
      </footer>
    </main>
 
    <!-- CodeMirror 5 JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script><!-- If we want HTML+XML highlight too -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/handlebars/handlebars.min.js"></script>

    <!-- Tree widget and Handlebars runtime (local) -->
    <script src="tree.min.js"></script>

    <!-- Handlebars Runtime -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.7.8/handlebars.min.js"></script>
    
    <!-- Other scripts -->
    <script src="resizable-columns.js"></script>
    <script>
      // --- Editor initialization ---
      const inputTextarea = document.getElementById('inputInstance');
      const templateTextarea = document.getElementById('template-editor');
      const outputTextarea = document.getElementById('out');

      const inputEditor = CodeMirror.fromTextArea(inputTextarea, { mode: 'application/json', lineNumbers: true, tabSize: 2 });
      const templateEditor = CodeMirror.fromTextArea(templateTextarea, { mode: 'text/x-handlebars-template', lineNumbers: true, tabSize: 2 });
      const outputEditor = CodeMirror.fromTextArea(outputTextarea, { mode: 'application/json', lineNumbers: true, readOnly: true });

      // small helper used by tree integration
      function buildHandlebarsPath(pathArray) {
        if (!Array.isArray(pathArray)) return '';
        return pathArray.map(p => {
          if (typeof p === 'number') return p;
          if (/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(String(p))) return String(p);
          return `[\'${String(p).replace(/\\/g,'\\\\').replace(/'/g, "\\'")}\']`;
        }).join('.');
      }

      // Use the provided Tree widget (tree.min.js) for rendering and selection.
      const jsonTreeContainer = document.getElementById('json-tree-container');
      let treeInstance = null;

      // Convert arbitrary JSON into the tree widget's expected node format.
      let _idCounter = 1;
      function nextId() { return 'n' + (_idCounter++); }

      function jsonToTreeNodes(value, path = []) {
        const type = Object.prototype.toString.call(value);
        if (type === '[object Object]') {
          return Object.keys(value).map(key => {
            const nodePath = path.concat(key);
            const children = jsonToTreeNodes(value[key], nodePath);
            return { id: nextId(), text: String(key), path: nodePath, children: children.length ? children : undefined };
          });
        }
        if (type === '[object Array]') {
          return value.map((item, i) => {
            const nodePath = path.concat(i);
            const children = jsonToTreeNodes(item, nodePath);
            return { id: nextId(), text: '[' + i + ']', path: nodePath, children: children.length ? children : undefined };
          });
        }
        // primitive
        return [{ id: nextId(), text: String(value), path: path }];
      }

      function insertPathsFromNodes(nodes) {
        if (!nodes || nodes.length === 0) return;
        const inserts = nodes.map(n => `{{${buildHandlebarsPath(n.path)}}}`);
        templateEditor.replaceSelection(inserts.join('\n'));
        templateEditor.focus();
      }

      function updateJsonTree(jsonString) {
        jsonTreeContainer.innerHTML = '';
        try {
          const jsonData = JSON.parse(jsonString);
          _idCounter = 1;
          const treeData = jsonToTreeNodes(jsonData, []);

          // Actions UI
          const actions = document.createElement('div');
          actions.className = 'tree-actions';
          const insertButton = document.createElement('button');
          insertButton.textContent = 'Insert Selected Paths';
          insertButton.id = 'insert-selected-paths';
          insertButton.addEventListener('click', () => {
            if (treeInstance) insertPathsFromNodes(treeInstance.selectedNodes);
          });
          const selectedList = document.createElement('div');
          selectedList.id = 'selected-paths';
          selectedList.style.marginTop = '8px';
          actions.appendChild(insertButton);
          actions.appendChild(selectedList);
          jsonTreeContainer.appendChild(actions);

          // Initialize Tree widget into our container
          const selector = '#json-tree-container';
          treeInstance = new Tree(selector, {
            data: treeData,
            onChange: function() {
              const selected = this.selectedNodes || [];
              const selectedListEl = document.getElementById('selected-paths');
              selectedListEl.innerHTML = '';
              if (!selected || selected.length === 0) {
                selectedListEl.textContent = 'No nodes selected. Use checkboxes to select nodes.';
                return;
              }
              const ul = document.createElement('ul');
              for (const n of selected) {
                const li = document.createElement('li');
                const btn = document.createElement('button');
                btn.textContent = buildHandlebarsPath(n.path);
                btn.style.cursor = 'pointer';
                btn.addEventListener('click', () => {
                  templateEditor.replaceSelection(`{{${buildHandlebarsPath(n.path)}}}`);
                  templateEditor.focus();
                });
                li.appendChild(btn);
                ul.appendChild(li);
              }
              selectedListEl.appendChild(ul);
            }
          });

function insertSelectedPathsAtCursor() {
        if (!selectedPaths || selectedPaths.length === 0) return;
        const inserts = selectedPaths.map(p => `{{${buildHandlebarsPath(p)}}}`);
        templateEditor.replaceSelection(inserts.join('\n'));
        templateEditor.focus();
      }

      // --- Initialize CodeMirror Editors ---
      const templateEditor = CodeMirror.fromTextArea(document.getElementById('template-editor'), {
        lineNumbers: true,
        mode: { name: 'handlebars', base: 'text/html' },
      });

      const inputEditor = CodeMirror.fromTextArea(document.getElementById('inputInstance'), {
        lineNumbers: true,
        mode: { name: 'javascript', json: true },
      });

      const outputEditor = CodeMirror.fromTextArea(document.getElementById('out'), {
        lineNumbers: true,
        mode: 'htmlmixed',
        readOnly: true
      });

      // Set initial content
      const initialJson = '{\n  "message": "Paste JSON here or select an example.",\n  "tip": "Click a node below to copy its path to the cursor/selection in the conversion template."\n}';
      inputEditor.setValue(initialJson);
      outputEditor.setValue('Output goes here after conversion is run.');

      // --- Event Handlers ---
      document.getElementById('run-conversion').addEventListener('click', () => {
        try {
          // 1. Get template and input from editors
          const templateString = templateEditor.getValue();
          const jsonString = inputEditor.getValue();

          if (!jsonString.trim()) {
            outputEditor.setValue('Input JSON is empty.');
            return;
          }
          const data = JSON.parse(jsonString);

          // 2. Compile the template
          const template = Handlebars.compile(templateString);

          // 3. Execute the template with the data
          const resultHtml = template(data);

          // 4. Display the resulting HTML in the output editor
          outputEditor.setValue(resultHtml);
        } catch (e) {
          jsonTreeContainer.innerHTML = '<p style="color:red;">Invalid JSON. Error message:<br>'+e.message+'</p>';
        }
      }

      // File input handling
      document.getElementById('fileInput').addEventListener('change', function(ev) {
        const file = ev.target.files && ev.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const content = e.target.result;
            inputEditor.setValue(content);
            updateJsonTree(content);
          };
          reader.readAsText(file);
        }
      });

      // Example selection
      document.getElementById('exampleSelect').addEventListener('change', function() {
        const selectedFile = this.value;
        if (selectedFile) {
          fetch(`example/instance/${selectedFile}`)
            .then(response => response.ok ? response.text() : Promise.reject('Network response was not ok'))
            .then(data => {
              inputEditor.setValue(data);
              updateJsonTree(data);
            })
            .catch(error => {
              console.error('There was a problem with the fetch operation:', error);
              const msg = 'Error loading file: ' + selectedFile;
              inputEditor.setValue(JSON.stringify({ error: msg }, null, 2));
            });
        }
      });

      // Run conversion button
      document.getElementById('run-conversion').addEventListener('click', () => {
        const templateString = templateEditor.getValue();
        let inputData;
        try {
          inputData = JSON.parse(inputEditor.getValue());
        } catch (e) {
          alert('Invalid input JSON: ' + e.message);
          return;
        }
        try {
          if (window.Handlebars && typeof Handlebars.compile === 'function') {
            const fn = Handlebars.compile(templateString);
            const result = fn(inputData);
            outputEditor.setValue(result);
          } else if (window.Handlebars && typeof Handlebars.template === 'function' && typeof Handlebars.precompile === 'function') {
            // As a fallback, try precompilation (may not be available in runtime-only builds)
            const pre = Handlebars.precompile(templateString);
            outputEditor.setValue(pre);
          } else {
            outputEditor.setValue('Handlebars not available in this environment.');
          }
        } catch (e) {
          alert('Conversion error: ' + e.message);
        }
      });

      // when show-compiled button is clicked, show the compiled template
      var showCompiledButton = document.getElementById('show-compiled');
      showCompiledButton.addEventListener('click', () => {
        const templateString = templateEditor.getValue();
        try {
          var precompiledTemplate = Handlebars.precompile ? Handlebars.precompile(templateString) : 'Precompile not available';
          const conversionContainer = document.getElementById('conversion-container');
          const compiledTextarea = document.createElement('textarea');
          compiledTextarea.id = 'precompiled-textarea';
          compiledTextarea.style.width = '100%';
          compiledTextarea.style.height = '50%';
          compiledTextarea.readOnly = true;
          compiledTextarea.value = precompiledTemplate;
          conversionContainer.insertBefore(compiledTextarea, showCompiledButton);
          showCompiledButton.style.display = 'none'; // hide the button after click
          // add a copy to clipboard button to the alert that copies the template to clipboard
          const copyButton = document.createElement('button');
          copyButton.textContent = 'Copy precompiled template to Clipboard (+close)';
          copyButton.id = 'copy-precompiled-button';
          conversionContainer.appendChild(copyButton);
          copyButton.style.cursor = 'pointer';
          copyButton.onclick = () => {
            navigator.clipboard.writeText(precompiledTemplate).then(() => {
              // show text "Copied!" on the button for 1 second then remove the textarea and copy button;
              copyButton.textContent = 'Copied!';
              setTimeout(() => {
                conversionContainer.removeChild(compiledTextarea);
                conversionContainer.removeChild(copyButton);
                showCompiledButton.style.display = 'inline'; // show the show-compiled button again
              }, 1000);
            });
          };
        } catch (e) {
          alert('Error during precompilation:\n\n' + e.message);
          console.error('Precompilation Error:', e);
        }
      });

      // When content of template-editor changes: If compiled-textarea exists, remove it + copy button and show the show-compiled button again
      templateEditor.on('change', () => {
        console.log("Template editor changed, removing precompiled view if exists.");
        const conversionContainer = document.getElementById('conversion-container');
        const compiledTextarea = document.getElementById('precompiled-textarea');
        const copyButton = document.getElementById('copy-precompiled-button');
        if (compiledTextarea && copyButton) {
          conversionContainer.removeChild(compiledTextarea);
          conversionContainer.removeChild(copyButton);
          showCompiledButton.style.display = 'inline'; // show the show-compiled button again
        }
      });

      document.getElementById('toggle-line-numbers').addEventListener('change', function() {
        const showLineNumbers = this.checked;
        const editors = [inputEditor, templateEditor, outputEditor];
        editors.forEach(editor => editor.setOption('lineNumbers', showLineNumbers));
      });

      // Update tree when user types in the input editor
      inputEditor.on('change', (editor) => {
        updateJsonTree(editor.getValue());
      });

      //   Trigger initial render of the JSON tree
      // const initialJson = inputEditor.getValue();
      // updateJsonTree(initialJson);
    </script>
  </body>
</html>
