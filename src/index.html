<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Kintegrate</title>
    <script>
      const APP_VERSION = 'v0.3.4';
    </script>
    <link rel="stylesheet" href="resizable-columns.css">
    <!--  css for tree widget -->
    <link rel="stylesheet" href="tree.min.css">
    <!-- CodeMirror 5 CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <!-- Application styles -->
    <link rel="stylesheet" href="kintegrate.css">
    <style>
      .success {
        background-color: #4caf50 !important;
        border-color: #2e7d32 !important;
      }
      .toggle-button.active .auto-convert-icon-fill {
        fill: #4caf50;
        opacity: 0.3;
      }
      .toggle-button {
        background: none;
        border: 1px solid #ccc;
        padding: 4px;
        cursor: pointer;
        border-radius: 4px;
      }
      .toggle-button.active {
        background-color: #e8f5e9;
        border-color: #4caf50;
      }
      .toggle-button:hover {
        border-color: #999;
      }
      .toggle-button.active:hover {
        border-color: #2e7d32;
      }
    </style>


  </head>
  <body>
    <main>
      <div class="fullheight-container" id="main-container">
        <!-- div id="input-wrapper" -->
          <div class="column column-left">
            <div id="input-container">
              <!-- file picker that can pick files from user upload -->
              Pick example file <input type="file" id="fileInput" accept=".json,.xml,.txt"><br>
              or select example:
              <!-- Dropdown that can load any existing file in web server side subdirectory /example/instance into the textarea that has id="inputInstance"  -->
              <select id="exampleSelect">
                <option value="">--Select an example--</option>
                <option value="intro.json">intro.json</option>
                <option value="MDK_Rek_demo1.json">MDK_Rek_demo1.json</option>
                <option value="mdk_lunga_1.json">mdk_lunga_1.json</option>
                <option value="non_existing_example.json">non_existing_example.json</option>
              </select><br>
              or just paste input into the box below<br>
              <textarea id="inputInstance">Input example goes here</textarea>
              <hr>
              <div id="json-tree-container">Parsed input from above goes here into a foldable tree. The tree-branches can then be clicked to get paths that can be used in conversion template</div>
            </div>
            <div id="input-footer">
              <div class="footer-controls">
                <label title="Adjust tree depth (0 = show all)">
                  Depth: <input type="range" id="tree-depth-slider" min="1" max="6" value="6" class="compact-slider">
                  <span class="slider-value" id="depth-value">All</span>
                </label>
                <label title="Adjust tree item size">
                  | Size: <input type="range" id="tree-size-slider" min="10" max="150" value="100" class="compact-slider">
                  <span class="slider-value" id="size-value">100%</span>
                </label>
              </div>
            </div>
          </div>
        <!-- /div -->

        <div class="resizer"></div>

        <div class="column column-center">
          <div id="conversion-container">
            <div id="selection-list">
              <div class="tree-actions">
                <button id="insert-selected-paths" style="display: none;">↔ Insert all selected nodes as flat paths!!</button>
              </div>
            </div>
              <div>Conversion Template (Handlebars)</div>
              <textarea id="template-editor">
{{!-- <--- This is how you start a comment block in Handlebars
  This is the column where you author (and possibly compile) your conversion script.
  Currently you see a simple Handlebars template.
  After importing instance data and/or schema (or other structure defitnitions) they can help you author the conversion script.
  Select nodes in the tree on the left to insert paths to data elements at the current cursor position in this template.
 This ends comment block:   --}}
 
If intro.json is loaded as source this example will work, otherwise likely a lot of blank spots:
----- Start -----
Remember, ⤡ means: {{starter_tips.tip_object.Right_click_explanations.[⤡]}}

A number of tips:
{{#with starter_tips}}
  {{#each tip_array}}
- {{.}}
  {{/each}}
{{/with}}
----- The end -----

{{!-- Another comment block. Remove this line to run it
  
The examples below fit with the example input file MDK_Rek_demo1.json

Example with full flat path: 
  {{granskning.bakgrund.0.sjukdomshistoria.0.ospecificerad_händelse.0.anamnes.0.[|value]}}

Example looping/traversing tree combined with parital flat 
paths when we have reached a relevant repeating level:
  {{#with granskning}}
    {{#each rubrik}}
      {{#each behållare}}
        {{#each deltagare}} {{! this is a list with potentially many rows }}
Närvarande:
          {{#each deltagare}} 
{{namn.0.[|value]}} (Specialitet: {{vårdgivarroll.0.specialitet.0.[|value]}})
          {{/each}}
        {{/each}}
      {{/each}}
    {{/each}}
  {{/with}}

Bakgrund:
{{#with granskning}}
  {{#each bakgrund}}
    {{#each sjukdomshistoria}}
      {{#each ospecificerad_händelse}}
 Aktuellt: {{aktuellt.0.[|value]}}
 Anamnes: {{anamnes.0.[|value]}}
 Komorbiditet: {{komorbiditet.0.[|value]}}
      {{/each}}
    {{/each}}
  {{/each}}
{{/with}}

  This ends the second comment block:   --}}

</textarea>
            <div id="conversion-buttons" class="editor-buttons">
              <button id="erase-button" title="Clear editor content (can be undone)">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                  <path d="M16 9H8v10h8zm-.47 7.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12 1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14z" opacity=".3"></path>
                  <path d="M14.12 10.47 12 12.59l-2.13-2.12-1.41 1.41L10.59 14l-2.12 2.12 1.41 1.41L12 15.41l2.12 2.12 1.41-1.41L13.41 14l2.12-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4zM6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM8 9h8v10H8z"></path>
                </svg>
              </button>
              <button id="undo-button" title="Undo last change (Ctrl+Z)">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                  <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8"></path>
                </svg>
              </button>
              <button id="redo-button" title="Redo last undone change (Ctrl+Y)">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                  <path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7z"></path>
                </svg>
              </button>
              <button id="copy-button" title="Copy conversion template to clipboard">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                  <path d="M9 4h9v12H9z" opacity=".3"></path>
                  <path d="M18 2H9c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2m0 14H9V4h9zM3 15v-2h2v2zm0-5.5h2v2H3zM10 20h2v2h-2zm-7-1.5v-2h2v2zM5 22c-1.1 0-2-.9-2-2h2zm3.5 0h-2v-2h2zm5 0v-2h2c0 1.1-.9 2-2 2M5 6v2H3c0-1.1.9-2 2-2"></path>
                </svg>
              </button>
              <button id="download-button" title="Download editor content">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                  <path d="M19 9h-4V3H9v6H5l7 7zM5 18v2h14v-2z"></path>
                </svg>
              </button>
              <button id="show-compiled" title="Toggle precompiled template view" class="toggle-button">
                <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                  <path  d="M4 18h16V8H4zm8-3h6v2h-6zm-5.91-4.59L7.5 9l4 4-4 4-1.41-1.41L8.67 13z" opacity=".3"></path>
                  <path d="M12 15h6v2h-6z"></path>
                  <path d="M20 4H4c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.89-2-2-2m0 14H4V8h16z"></path>
                  <path d="m7.5 17 4-4-4-4-1.41 1.41L8.67 13l-2.58 2.59z"></path>
                </svg>
              </button>
              <button id="auto-convert-button" title="Toggle auto-conversion" class="toggle-button">
                  <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                      <path class="auto-convert-icon-fill" d="M12 4c-4.41 0-8 3.59-8 8s3.59 8 8 8 8-3.59 8-8-3.59-8-8-8m-1 12H9V8h2zm1 0V8l5 4z" opacity=".3"></path>
                      <path d="M12 4c4.41 0 8 3.59 8 8s-3.59 8-8 8-8-3.59-8-8 3.59-8 8-8m0-2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m-1 6H9v8h2zm6 4-5-4v8z"></path>
                  </svg>
              </button>
            </div> <!-- .editor-buttons -->
            <div id="precompile-container" style="position: relative;">
              <textarea id="precompiled-textarea" style="display: none; width: 100%; height: 200px; margin-top: 10px; padding: 8px; padding-right: 70px; resize: vertical; box-sizing: border-box;"></textarea>
              <div id="precompiled-buttons" style="display: none; position: absolute; right: 24px; top: 18px; z-index: 10; background: white; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: none; flex-direction: row;">
                <button id="copy-precompiled-button" title="Copy precompiled template to clipboard" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center;">
                  <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width: 20px; height: 20px;">
                    <path d="M9 4h9v12H9z" opacity=".3"></path>
                    <path d="M18 2H9c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2m0 14H9V4h9zM3 15v-2h2v2zm0-5.5h2v2H3zM10 20h2v2h-2zm-7-1.5v-2h2v2zM5 22c-1.1 0-2-.9-2-2h2zm3.5 0h-2v-2h2zm5 0v-2h2c0 1.1-.9 2-2 2M5 6v2H3c0-1.1.9-2 2-2"></path>
                  </svg>
                </button>
                <button id="close-precompiled-button" title="Close precompiled view" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center;">
                  <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width: 20px; height: 20px;">
                    <path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
                  </svg>
                </button>
              </div>
            </div>
          </div> <!--  -->
          <div id="conversion-footer">Template status: Ready</div>
        </div> <!-- .column-center -->
        <div class="resizer"></div>
        <div class="column column-right">
            <div id="output-container">
              <textarea id="out">Output goes here after conversion is run</textarea>
            </div>
            <div id="output-footer">Output status: Ready</div>
          </div>
      </div>
    </main>
    <footer>
          <strong>K!ntegrate</strong> <span id="app-version"></span>  A rudimentary integration tool with roots at <strong><a href="https://www.karolinskahospital.com/">K</a></a></strong>. 
          || Settings:
          <label style="cursor: pointer;"><input type="checkbox" id="toggle-line-numbers" checked>Show line numbers</label>
          | <label style="cursor: pointer;"><input type="checkbox" id="toggle-column-footers" checked>Show column footers</label>
          | <label>Auto-convert delay (ms):<input type="number" id="auto-convert-delay" min="100" max="5000" value="500" style="width:4em; margin-left:6px;"></label>
     </footer>
 
    <!-- CodeMirror 5 JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <!-- Add simple mode addon first, required by handlebars mode -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/mode/simple.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/handlebars/handlebars.min.js"></script>
    <!-- Add undo/redo addon -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/undo/undo.min.js"></script>

    <!-- Tree widget and Handlebars runtime (local) -->
    <script src="tree.min.js"></script>
    <script src="extended-tree.js"></script>

    <!-- Handlebars Runtime -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.7.8/handlebars.min.js"></script>
    
    <!-- Other scripts -->
    <script src="resizable-columns.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
      // Set version in footer
      document.getElementById('app-version').innerHTML = '<a href="https://github.com/ErikSundvall/kintegrate#'+APP_VERSION+'">'+APP_VERSION+'</a>';

      // --- Editor initialization ---
      const inputTextarea = document.getElementById('inputInstance');
      const templateTextarea = document.getElementById('template-editor');
      const outputTextarea = document.getElementById('out');

      const inputEditor = CodeMirror.fromTextArea(inputTextarea, { mode: 'application/json', lineNumbers: true, tabSize: 2 });
      // Get the pre-defined buttons
      const undoButton = document.getElementById('undo-button');
      const redoButton = document.getElementById('redo-button');
      const eraseButton = document.getElementById('erase-button');

      // Initialize CodeMirror with undo/redo history
      const templateEditor = CodeMirror.fromTextArea(templateTextarea, {
        mode: 'text/x-handlebars-template',
        lineNumbers: true,
        tabSize: 2,
        undoDepth: 200,  // Number of undo levels to keep
        historyEventDelay: 200  // Delay in ms to merge changes into one undo event
      });

      // Auto-conversion functionality
      let autoConvertEnabled = true; // Enabled by default
      let autoConvertTimeout = null;
      
      function debounce(func, wait) {
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(autoConvertTimeout);
            func(...args);
          };
          clearTimeout(autoConvertTimeout);
          autoConvertTimeout = setTimeout(later, wait);
        };
      }
      
      function runConversion() {
        try {
          const templateString = templateEditor.getValue();
          const jsonString = inputEditor.getValue();

          if (!jsonString.trim()) {
            outputEditor.setValue('Input JSON is empty.');
            return;
          }
          
          const data = JSON.parse(jsonString);
          const template = Handlebars.compile(templateString);
          const resultHtml = template(data);
          outputEditor.setValue(resultHtml);
        } catch (e) {
          outputEditor.setValue('Error: ' + e.message);
        }
      }

      // Set up auto-convert button
      const autoConvertButton = document.getElementById('auto-convert-button');
      const autoConvertDelay = document.getElementById('auto-convert-delay');
      
      // Set initial active state
      autoConvertButton.classList.add('active');
      
      autoConvertButton.addEventListener('click', () => {
        autoConvertEnabled = !autoConvertEnabled;
        autoConvertButton.classList.toggle('active', autoConvertEnabled);
        if (autoConvertEnabled) {
          // Run once immediately when enabled
          runConversion();
        }
      });

      // Set up debounced conversion
      const debouncedConvert = () => {
        if (!autoConvertEnabled) return;
        const delay = parseInt(autoConvertDelay.value, 10) || 500;
        debounce(runConversion, delay)();
      };

      // Listen for changes in the template editor
      templateEditor.on('change', debouncedConvert);

      // Set up tree depth slider
      const treeDepthSlider = document.getElementById('tree-depth-slider');
      const depthValue = document.getElementById('depth-value');
      
      treeDepthSlider.addEventListener('input', () => {
        const value = parseInt(treeDepthSlider.value);
        const depth = value === 6 ? 0 : value; // 6 = infinite (0)
        depthValue.textContent = depth === 0 ? 'All' : depth;
        
        if (treeInstance) {
          treeInstance.options = treeInstance.options || {};
          treeInstance.options.closeDepth = depth;
          treeInstance.render(treeInstance.treeNodes);
          // Update visual states
          if (treeInstance.nodesById) {
            Object.values(treeInstance.nodesById).forEach(n => {
              try { treeInstance.updateLiElement && treeInstance.updateLiElement(n); } catch (err) { /* ignore */ }
            });
          }
        }
      });

      // Set up tree size slider
      const treeSizeSlider = document.getElementById('tree-size-slider');
      const sizeValue = document.getElementById('size-value');
      
      // Move ensureTreeWrapper to a higher scope
      const ensureTreeWrapper = () => {
        console.log('Ensuring tree wrapper...');
        const container = document.getElementById('json-tree-container');
        console.log('Container found:', container);
        if (container) {
          // Find the tree's ul element (the main nodes container)
          const treeUl = container.querySelector('.treejs-nodes');
          if (treeUl && !treeUl.closest('.tree-scale-wrapper')) {
            console.log('Creating new wrapper around tree nodes');
            const wrapper = document.createElement('div');
            wrapper.className = 'tree-scale-wrapper';
            // Wrap only the ul element
            treeUl.parentNode.insertBefore(wrapper, treeUl);
            wrapper.appendChild(treeUl);
            console.log('Wrapper created and populated');
          } else {
            console.log('Tree nodes or wrapper not found');
          }
        } else {
          console.log('Container not found');
        }
      };

      // Scale application function
      const applyTreeScale = (scale) => {
        const wrapper = document.getElementById('json-tree-container')
          ?.querySelector('.tree-scale-wrapper');
        if (wrapper) {
          console.log('Applying scale:', scale);
          wrapper.style.transform = `scale(${scale})`;
        }
      };

      let scaleTimeout = null;
      treeSizeSlider.addEventListener('input', () => {
        console.log('Size slider changed');
        const value = parseInt(treeSizeSlider.value);
        sizeValue.textContent = value + '%';
        const scale = value / 100;
        
        // Clear any pending timeout
        if (scaleTimeout) {
          clearTimeout(scaleTimeout);
        }
        
        // Apply scale immediately
        applyTreeScale(scale);
        
        // Track last scale that triggered a rerender
        treeSizeSlider.lastRenderScale = treeSizeSlider.lastRenderScale || 1;
        
        // Schedule a rerender if scale change is significant
        const scaleChange = Math.abs(scale - treeSizeSlider.lastRenderScale);
        if (scaleChange > 0.3 || scale <= 0.7) {
          scaleTimeout = setTimeout(() => {
            console.log(`Rerendering tree due to significant scale change (${scaleChange.toFixed(2)})`);
            if (treeInstance && treeInstance.treeNodes) {
              const currentScale = parseInt(treeSizeSlider.value) / 100;
              treeInstance.render(treeInstance.treeNodes);
              ensureTreeWrapper();
              // Wait a bit for the DOM to update before reapplying scale
              requestAnimationFrame(() => {
                applyTreeScale(currentScale);
                treeSizeSlider.lastRenderScale = currentScale;
              });
            }
          }, 500); // Wait for slider to settle
        }
      });

      // Set up column footers toggle
      const footersToggle = document.getElementById('toggle-column-footers');
      footersToggle.addEventListener('change', () => {
        document.body.classList.toggle('hide-column-footers', !footersToggle.checked);
      });

      // Setup undo/redo button handlers
      undoButton.onclick = () => {
        if (templateEditor.historySize().undo > 0) {
          templateEditor.undo();
          templateEditor.focus();
        }
      };
      redoButton.onclick = () => {
        if (templateEditor.historySize().redo > 0) {
          templateEditor.redo();
          templateEditor.focus();
        }
      };

      // Update button states based on history availability
      function updateButtonStates() {
        const history = templateEditor.historySize();
        undoButton.disabled = history.undo === 0;
        redoButton.disabled = history.redo === 0;
      }

      // Listen for changes to update button states
      templateEditor.on('change', updateButtonStates);
      updateButtonStates();

      // Setup copy button handler
      document.getElementById('copy-button').onclick = () => {
        const content = templateEditor.getValue();
        navigator.clipboard.writeText(content).then(() => {
          // Visual feedback using CSS class
          const copyButton = document.getElementById('copy-button');
          copyButton.classList.add('success');
          setTimeout(() => {
            copyButton.classList.remove('success');
          }, 1000);
        });
      };

      // Setup erase button handler
      eraseButton.onclick = () => {
        templateEditor.setValue('');
        templateEditor.focus();
      };

      // Setup download button handler
      const downloadButton = document.getElementById('download-button');
      downloadButton.onclick = () => {
        // Create filename with current date/time
        const now = new Date();
        const timestamp = now.toISOString()
          .replace(/:/g, '-')  // Replace colons with dashes
          .replace(/\./g, '-') // Replace dot with dash
          .replace(/T/, '_')   // Replace T with underscore
          .slice(0, -1);       // Remove the Z at the end
        const filename = `Kintegrate_${timestamp}.txt`;

        // Create blob and download link
        const content = templateEditor.getValue();
        const blob = new Blob([content], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        window.URL.revokeObjectURL(url);
      };

      // Set up precompiled view functionality
      const showPrecompiledButton = document.getElementById('show-compiled');
      const precompiledTextarea = document.getElementById('precompiled-textarea');
      const precompiledButtons = document.getElementById('precompiled-buttons');
      const copyPrecompiledButton = document.getElementById('copy-precompiled-button');
      const closePrecompiledButton = document.getElementById('close-precompiled-button');

      let autoPrecompileEnabled = false;
      let precompileTimeout = null;

      function updatePrecompiledView() {
        const templateString = templateEditor.getValue();
        try {
          const compiled = Handlebars.precompile(templateString);
          precompiledTextarea.value = compiled;
        } catch (e) {
          precompiledTextarea.value = 'Error precompiling template: ' + e.message;
        }
      }

      function hidePrecompiledView() {
        precompiledTextarea.style.display = 'none';
        precompiledButtons.style.display = 'none';
        showPrecompiledButton.classList.remove('active');
        autoPrecompileEnabled = false;
      }

      function togglePrecompiledView() {
        autoPrecompileEnabled = !autoPrecompileEnabled;
        showPrecompiledButton.classList.toggle('active', autoPrecompileEnabled);
        
        if (autoPrecompileEnabled) {
          // Show the view and do initial update
          precompiledTextarea.style.display = 'block';
          precompiledButtons.style.display = 'flex';
          showPrecompiledButton.classList.add('active');
          updatePrecompiledView();
        } else {
          // Hide the view
          hidePrecompiledView();
          showPrecompiledButton.classList.remove('active');
        }
      }

      // Set up auto-update for precompiled view
      function debouncedPrecompileUpdate() {
        if (!autoPrecompileEnabled) return;
        const delay = parseInt(autoConvertDelay.value, 10) || 500;
        clearTimeout(precompileTimeout);
        precompileTimeout = setTimeout(updatePrecompiledView, delay);
      }

      // Listen for template changes to update precompiled view
      templateEditor.on('change', debouncedPrecompileUpdate);

      showPrecompiledButton.onclick = togglePrecompiledView;
      closePrecompiledButton.onclick = hidePrecompiledView;

      copyPrecompiledButton.onclick = () => {
        navigator.clipboard.writeText(precompiledTextarea.value).then(() => {
          // Visual feedback using CSS class
          copyPrecompiledButton.classList.add('success');
          setTimeout(() => {
            copyPrecompiledButton.classList.remove('success');
          }, 1000);
        });
      };
      const outputEditor = CodeMirror.fromTextArea(outputTextarea, { mode: 'application/json', lineNumbers: true, readOnly: true });
      const selectionListBox = document.getElementById('selection-list')
      const actions = document.getElementById('tree-actions');

      // small helper creating flat paths in Handlebars syntax
      function buildHandlebarsPath(pathArray, node) {
        if (!Array.isArray(pathArray)) return '';
        
        // Find the nearest context boundary ancestor
          function findNearestContextBoundary(currentNode) {
            if (!currentNode || !currentNode.path) return null;
            
            // First check if the current node itself is a boundary
            if (treeInstance.isContextBoundary(currentNode.id)) {
              return currentNode;
            }
            
            // Look up parent by ID instead of reconstructing from path
            let current = currentNode;
            while (current && current.parentId) {
              current = treeInstance.nodesById[current.parentId];
              if (current && treeInstance.isContextBoundary(current.id)) {
                return current;
              }            if (current && treeInstance.isContextBoundary(current.id)) {
              return current;
            }
          }
          return null;
        }
        
        // If we have a node, check for context boundary
        let processedPath = [...pathArray]; // Create a copy we can modify
        if (node) {
          const boundaryNode = findNearestContextBoundary(node);
          if (boundaryNode) {
            if (boundaryNode.id === node.id) {
              // If the node itself is the boundary, keep only what's after it
              processedPath = processedPath.slice(processedPath.length - 1);
            } else {
              // Trim path to start from boundary
              const boundaryDepth = boundaryNode.path.length;
              processedPath = processedPath.slice(boundaryDepth);
              
              // When there's a context boundary, we want to start with the first string segment
              // Find the index of the first string segment
              const firstStrIdx = processedPath.findIndex(p => typeof p === 'string');
              if (firstStrIdx > 0) {
                // Remove any leading numeric indices
                processedPath = processedPath.slice(firstStrIdx);
              }
            }
          }
        }
        
        // Convert path segments to Handlebars syntax
        return processedPath.map(p => {
          if (typeof p === 'number') return `[${p}]`; // Wrap array indices in square brackets
          if (/^[\p{L}_$][\p{L}\p{N}_$]*$/u.test(String(p))) return String(p);
          return `[${String(p).replace(/\\/g,'\\\\').replace(/]/g,'\\]')}]`;
        }).join('.');
      }

      // small helper creating tree-structs using {{#each ...}} or {{#with ...}} in Handlebars syntax based on a node deeper down in the structure
      function buildHandlebarsTree(node) {
        if (!node || !Array.isArray(node.path) || node.path.length === 0) return '';

        // Find the nearest context boundary ancestor
        function findNearestContextBoundary(currentNode) {
          if (!currentNode || !currentNode.path) return null;
          
          // First check if the current node itself is a boundary
          if (treeInstance.isContextBoundary(currentNode.id)) {
            return currentNode;
          }
          
          let current = currentNode;
          while (current) {
            // Get parent node by removing last element from path
            const parentPath = current.path.slice(0, -1);
            // Find node with this path including array indices
            current = Object.values(treeInstance.nodesById).find(
              n => n.path && n.path.length === parentPath.length && 
              n.path.every((v, i) => v === parentPath[i])
            );
            
            if (current && treeInstance.isContextBoundary(current.id)) {
              return current;
            }
          }
          return null;
        }

        // Get the context boundary ancestor if any
        const boundaryNode = findNearestContextBoundary(node);
        
        // If we have a context boundary, adjust the path appropriately
        let path;
        if (boundaryNode) {
          // Find array indices in the boundary path that we need to preserve
          const boundaryArrayIndices = boundaryNode.path
            .map((v, i) => typeof v === 'number' ? { index: i, value: v } : null)
            .filter(x => x !== null);
          
          if (boundaryNode.id === node.id) {f
            // If the node itself is the boundary, only use its last path segment
            path = [node.path[node.path.length - 1]];
          } else {
            // Otherwise trim path to start from boundary but preserve array indices
            path = node.path.slice(boundaryNode.path.length);
            
            // Insert necessary array indices from the boundary path
            boundaryArrayIndices.forEach(({ index, value }) => {
              if (index < boundaryNode.path.length) {
                // Insert array index at correct position relative to its parent
                const parentIndex = Math.max(0, index - 1);
                if (parentIndex < path.length) {
                  path.splice(parentIndex + 1, 0, value);
                }
              }
            });
          }
        } else {
          path = node.path;
        }

        let opens = [];
        let leaf = null;

        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          const next = path[i + 1];

          if (typeof p === 'number') {
            // numeric index is handled by the wrapper emitted for the previous property
            continue;
          }

          // If next is a number, this property is an array -> emit #each and skip the numeric index
          if (typeof next === 'number') {
            opens.push(`{{#each ${buildHandlebarsPath([p])}}}`);
            // skip the numeric index
            i++;
            continue;
          }

          // If there is another property after this, emit #with (object context)
          if (i < path.length - 1) {
            opens.push(`{{#with ${buildHandlebarsPath([p])}}}`);
            continue;
          }

          // Otherwise this is the leaf property
          leaf = buildHandlebarsPath([p]);
        }

        // If we still don't have a leaf (e.g. path ends in a number), pick last non-number segment
        if (!leaf) {
          for (let j = path.length - 1; j >= 0; j--) {
            if (typeof path[j] !== 'number') { leaf = buildHandlebarsPath([path[j]]); break; }
          }
        }

        // Build output with smarter nesting based on node type
        const lines = [];
        
        // For array nodes, modify the opens array to handle array properly
        if (node.nodeType === NODE_TYPE.ARRAY) {
            // Check if this is a specific array element by looking at the last path segment
            const isSpecificArrayElement = typeof path[path.length - 1] === 'number';
            
            // Remove any {{#each}} that might have been added for the array itself
            opens = opens.filter(o => !o.includes(leaf));
            
            // Add opening tags for parent contexts with indentation
            for (let idx = 0; idx < opens.length; idx++) {
                const indent = '  '.repeat(idx);
                lines.push(indent + opens[idx]);
            }

            // Add either with block for specific element or each block for whole array
            const indent = '  '.repeat(opens.length);
            if (leaf) {
                if (isSpecificArrayElement) {
                    // If a specific array element is selected, use {{#with}} and output the indexed value
                    const arrayPath = path.slice(0, -1);
                    const lastIndex = path[path.length - 1];
                    const arrayName = arrayPath.length > 0 ? buildHandlebarsPath(arrayPath) : leaf;
                    lines.push(indent + `{{#with ${arrayName}}}`);
                    lines.push(indent + `  {{[${lastIndex}]}}`);
                    lines.push(indent + '{{/with}}');
                } else {
                    // For the whole array, use {{#each}}
                    lines.push(indent + `{{#each ${leaf}}}`);
                    lines.push(indent + '  {{.}}');
                    lines.push(indent + '{{/each}}');
                }
            }
        } else {
            // Handle non-array nodes (objects and primitives)
            // Add opening tags with indentation (outer -> inner)
            for (let idx = 0; idx < opens.length; idx++) {
                const indent = '  '.repeat(idx);
                lines.push(indent + opens[idx]);
            }

            // Add inner content based on node type
            const indent = '  '.repeat(opens.length);
            if (node.nodeType === NODE_TYPE.OBJECT && leaf) {
                // For objects, add {{#with}} to access properties
                lines.push(indent + `{{#with ${leaf}}}`);
                lines.push(indent + '  {{.}}');
                lines.push(indent + '{{/with}}');
            } else if (node.nodeType === NODE_TYPE.ARRAY) {
                // Check if this is a specific array element
                const lastPathSegment = path[path.length - 1];
                const isSpecificArrayElement = typeof lastPathSegment === 'number';
                
                if (isSpecificArrayElement) {
                    // For specific array element, use {{#with}} and the index
                    const arrayPath = path.slice(0, -1);
                    const arrayName = arrayPath.map(p => typeof p === 'string' ? p : `[${p}]`).join('.');
                    lines.push(indent + `{{#with ${arrayName}}}`);
                    lines.push(indent + `  {{[${lastPathSegment}]}}`);
                    lines.push(indent + '{{/with}}');
                } else {
                    // For whole array, use {{#each}}
                    lines.push(indent + `{{#each ${leaf}}}`);
                    lines.push(indent + '  {{.}}');
                    lines.push(indent + '{{/each}}');
                }
            } else if (leaf) {
                // For primitives, just output the leaf value
                lines.push(indent + '{{' + leaf + '}}');
            }
        }

        // Add closing tags with matching indentation (inner -> outer)
        for (let k = opens.length - 1; k >= 0; k--) {
            const openTag = opens[k];
            const m = openTag.match(/^\{\{#(each|with)\s+/);
            const tag = m ? m[1] : 'with';
            const indent = '  '.repeat(k);
            lines.push(indent + `{{/${tag}}}`);
        }

        return lines.join('\n');
      }

      // Use the provided Tree widget (tree.min.js) for rendering and selection.
      const jsonTreeContainer = document.getElementById('json-tree-container');
      let treeInstance = null;

      // Node type constants
      const NODE_TYPE = {
        PRIMITIVE: 'primitive',
        ARRAY: 'array',
        OBJECT: 'object'
      };

      // Convert arbitrary JSON into the tree widget's expected node format.
      let _idCounter = 1;
      function nextId() { return 'n' + (_idCounter++); }

      // Create a node with common properties
      function createNode(id, text, path, nodeType, parent = null, children = undefined) {
        // Store parent ID instead of direct reference to avoid circular structure
        const parentId = parent ? parent.id : null;
        return {
          id,
          text,
          path,
          nodeType,
          parentId, // Store parent ID instead of direct reference
          children  // undefined for leaf nodes
        };
      }

      // Recursive function to convert JSON to tree nodes with cleaner array handling
      function jsTreeNodes(value, path = [], parent = null) {
        const type = Object.prototype.toString.call(value);

        // Handle plain objects
        if (type === '[object Object]') {
          const nodes = [];
          for (const key of Object.keys(value)) {
            const val = value[key];
            const basePath = path.concat(key);
            const nodeId = nextId();

            // Handle the value
            const valType = Object.prototype.toString.call(val);
            if (valType === '[object Object]') {
              // Object value
              const objNode = createNode(nodeId, key, basePath, NODE_TYPE.OBJECT, parent);
              const children = jsTreeNodes(val, basePath, objNode);
              if (children.length) objNode.children = children;
              nodes.push(objNode);
            } else if (Array.isArray(val)) {
              // Array value - use key as node text with array type indicator
              const arrayNode = createNode(nodeId, key, basePath, NODE_TYPE.ARRAY, parent);
              const children = val.map((item, i) => {
                const itemPath = basePath.concat(i);
                const itemId = nextId();
                const itemType = Object.prototype.toString.call(item);

                if (itemType === '[object Object]' || Array.isArray(item)) {
                  // Complex item (object/array)
                  const itemNode = createNode(
                    itemId,
                    Array.isArray(item) ? `[${i}]` : i.toString(),
                    itemPath,
                    Array.isArray(item) ? NODE_TYPE.ARRAY : NODE_TYPE.OBJECT,
                    arrayNode
                  );
                  const itemChildren = jsTreeNodes(item, itemPath, itemNode);
                  if (itemChildren.length) itemNode.children = itemChildren;
                  return itemNode;
                } else {
                  // Primitive item
                  return createNode(itemId, String(item), itemPath, NODE_TYPE.PRIMITIVE, arrayNode);
                }
              });
              
              if (children.length) arrayNode.children = children;
              nodes.push(arrayNode);
            } else {
              // Primitive value
              nodes.push(createNode(nodeId, `${key} = ${String(val)}`, basePath, NODE_TYPE.PRIMITIVE, parent));
            }
          }
          return nodes;
        }

        // Handle arrays (top level)
        if (Array.isArray(value)) {
          return value.map((item, i) => {
            const nodePath = path.concat(i);
            const nodeId = nextId();
            const itemType = Object.prototype.toString.call(item);

            if (itemType === '[object Object]' || Array.isArray(item)) {
              // Complex item (object/array)
              const node = createNode(
                nodeId,
                `[${i}]`,
                nodePath,
                Array.isArray(item) ? NODE_TYPE.ARRAY : NODE_TYPE.OBJECT,
                parent
              );
              const children = jsTreeNodes(item, nodePath, node);
              if (children.length) node.children = children;
              return node;
            } else {
              // Primitive item
              return createNode(nodeId, String(item), nodePath, NODE_TYPE.PRIMITIVE, parent);
            }
          });
        }

        // Primitive value
        return [createNode(nextId(), String(value), path, NODE_TYPE.PRIMITIVE, parent)];

      }

      function insertPathsFromNodes(nodes) {
        if (!nodes || nodes.length === 0) return;
        const inserts = nodes.map(n => `{{${buildHandlebarsPath(n.path)}}}`);
        templateEditor.replaceSelection(inserts.join('\n'));
        templateEditor.focus();
      }

      // Render the selected paths list. Accepts an array of node objects (deepest selected nodes).
      function renderSelectedPaths(nodes) {
        const selectedListEl = document.getElementById('selected-paths') || (() => {
          const el = document.createElement('div'); el.id = 'selected-paths'; el.style.marginTop = '8px'; document.getElementById('selection-list')?.appendChild(el); return el;
        })();

        // update count indicator
        const countEl = document.getElementById('number-of-selected-paths');
        if (countEl) {
          countEl.textContent = nodes && nodes.length ? `${nodes.length} selected` : '';
        }

        // show/hide actions area depending on selection
        const actionsWrap = document.querySelector('.tree-actions');
        if (actionsWrap) {
          if (!nodes || nodes.length === 0) {
            actionsWrap.style.display = 'none';
          } else {
            actionsWrap.style.display = '';
          }
        }

        // No toggle button updates needed

        if (!nodes || nodes.length === 0) {
          selectedListEl.textContent = 'No nodes selected. Use checkboxes to select nodes.';
          // ensure actions area hidden when no selection
          const actionsWrap = document.querySelector('.tree-actions');
          if (actionsWrap) actionsWrap.style.display = 'none';
          return;
        }

        const ul = document.createElement('ul');
        for (const n of nodes) {
          const li = document.createElement('li');

          // Tree structure generator button at start of row
          const treeIconBtn = document.createElement('button');
          treeIconBtn.type = 'button';
          treeIconBtn.className = 'path-icon';
          treeIconBtn.title = 'Selected path';
          treeIconBtn.style.border = '1px solid';
          treeIconBtn.style.background = 'transparent';
          treeIconBtn.style.padding = '3px';
          treeIconBtn.style.cursor = 'pointer';
          treeIconBtn.innerHTML = '⤡';
          treeIconBtn.addEventListener('click', () => {
            // For array elements, use direct template generation
            if (n.nodeType === NODE_TYPE.PRIMITIVE && typeof n.path[n.path.length - 1] === 'number') {
              // Get the array path (everything before the numeric index)
              const arrayPath = n.path.slice(0, -1);
              const lastIndex = n.path[n.path.length - 1];
              
              // Build the template with proper nesting and index access
              let template = arrayPath.reduce((acc, pathSegment, i) => {
                if (typeof pathSegment === 'string') {
                  return acc + `{{#with ${pathSegment}}}\n  ` + '  '.repeat(i);
                }
                return acc;
              }, '');
              
              template += `{{[${lastIndex}]}}`;
              
              // Add closing tags
              const closingTags = arrayPath.filter(p => typeof p === 'string')
                .map((_, i) => '  '.repeat(arrayPath.length - i - 2) + '{{/with}}')
                .reverse()
                .join('\n');
              
              if (closingTags) {
                template += '\n' + closingTags;
              }
              
              templateEditor.replaceSelection(template);
            } else {
              templateEditor.replaceSelection(buildHandlebarsTree(n));
            }
            templateEditor.focus();
          });
          li.appendChild(treeIconBtn);

          // Flat path button at second position of row
          const flatPathBtn = document.createElement('button');
          flatPathBtn.type = 'button';
          flatPathBtn.textContent = "↔ "+buildHandlebarsPath(n.path);
          flatPathBtn.style.cursor = 'pointer';
          flatPathBtn.style.border = '1px solid'
          flatPathBtn.addEventListener('click', () => {
            templateEditor.replaceSelection(`{{${buildHandlebarsPath(n.path)}}}`);
            templateEditor.focus();
          });
          li.appendChild(flatPathBtn);

          ul.appendChild(li);
        }

  // show actions area when we have selections
  const actionsWrap2 = document.querySelector('.tree-actions');
  if (actionsWrap2) actionsWrap2.style.display = '';

  selectedListEl.innerHTML = '';
  selectedListEl.appendChild(ul);
      }

      function updateJsonTree(jsonString) {
        try {
          const jsonData = JSON.parse(jsonString);
          _idCounter = 1;
          const treeData = jsTreeNodes(jsonData, []);
          
          // Clear the container before adding new content
          jsonTreeContainer.innerHTML = '';

          // Actions UI (create locally so we don't depend on external references)
          let actionsEl = document.getElementById('tree-actions');
          if (!actionsEl) {
            actionsEl = document.createElement('div');
            actionsEl.id = 'tree-actions';
            actionsEl.className = 'tree-actions';
          } else {
            // clear previous children to avoid duplicates
            actionsEl.innerHTML = '';
          }

          // Set up insert button for selected paths
          const insertButton = document.createElement('button');
          insertButton.textContent = '↔ Insert all selected nodes as flat Paths';
          insertButton.id = 'insert-selected-paths';
          insertButton.style.display = 'none';  // Hidden by default
          insertButton.addEventListener('click', () => {
            if (!treeInstance) return;
            const selected = treeInstance.selectedNodes || [];
            const selectedNodes = selected.filter(n => n && n.status === 2 && Array.isArray(n.path));
            if (selectedNodes.length > 0) {
              insertPathsFromNodes(selectedNodes);
            }
          });

          let selectedList = document.getElementById('selected-paths');
          if (!selectedList) {
            selectedList = document.createElement('div');
            selectedList.id = 'selected-paths';
            selectedList.style.marginTop = '8px';
            // hidden by default
            selectedList.style.display = '';
          } else {
            selectedList.innerHTML = '';
            // always visible
            selectedList.style.display = '';
          }

          // No toggle button needed
          actionsEl.appendChild(insertButton);
          
          actionsEl.appendChild(selectedList);

          // Attach to selection list container (replace existing contents)
          const selBox = document.getElementById('selection-list');
          if (selBox) {
            selBox.innerHTML = '';
            selBox.appendChild(actionsEl);
          }

          // Initialize Tree widget into our container
          const selector = '#json-tree-container';
          let initialTreeDepth = 0;
          const treeDepthControl = document.getElementById('tree-depth-slider');
          if (treeDepthControl) {
            const sliderValue = parseInt(treeDepthControl.value);
            initialTreeDepth = sliderValue === 6 ? 0 : sliderValue;
          }
          
          // Clear node path lookup before initializing tree
          jsTreeNodes.nodesByPath = new Map();
          
          // Note: ensureTreeWrapper is now defined in a higher scope

          // Initialize tree with our extended version that includes context boundary support
          treeInstance = new ExtendedTree(selector, {
            data: treeData,
            closeDepth: initialTreeDepth,
            onCreateLi: function(node, li) {
              // Add node type classes during rendering
              if (node.nodeType) {
                li.classList.add('node-' + node.nodeType);
              }
              // Ensure wrapper exists after tree renders
              ensureTreeWrapper();
            },
            
            // Add node type classes during rendering
            onCreateLi: function(node, li) {
              if (node.nodeType) {
                li.classList.add('node-' + node.nodeType);
              }
            },

            onChange: function() {
              const selected = this.selectedNodes || [];
              const insertButton = document.getElementById('insert-selected-paths');
              
              // Show/hide insert button based on selection
              if (insertButton) {
                insertButton.style.display = selected.some(n => n && n.status === 2) ? '' : 'none';
              }
            } // end of onChange
          });

          // ****************************
          // Right-click on a node: toggle that node only (don't cascade to descendants)
          // This preserves children selection states but updates ancestor statuses.
          
          // Right-click on a node: show context menu with options
          jsonTreeContainer.addEventListener('contextmenu', (ev) => {
              if (!treeInstance) return;
              ev.preventDefault();
              
              // Find clicked element
              let el = ev.target;
              while (el && el !== jsonTreeContainer) {
                  if (el.tagName === 'LI' && el.classList.contains('treejs-node')) break;
                  el = el.parentElement;
              }
              
              // Exit if no valid tree node found
              if (!el || el === jsonTreeContainer) return;
              
              // Get node data from the tree widget
              const nodeId = el.nodeId;
              if (!nodeId || !treeInstance.nodesById) return;
              
              const node = treeInstance.nodesById[nodeId];
              if (!node) return;
              
              // Remove any existing menus
              const existingMenu = document.querySelector('.kintegrate-context-menu');
              if (existingMenu) {
                  existingMenu.parentNode.removeChild(existingMenu);
              }
              
              // Create and position the context menu
              const menu = document.createElement('div');
              menu.className = 'kintegrate-context-menu';
              menu.style.position = 'fixed';  // Changed from 'absolute' to 'fixed'
              menu.style.left = ev.clientX + 'px';  // Use clientX instead of pageX
              menu.style.top = ev.clientY + 'px';   // Use clientY instead of pageY
              menu.style.zIndex = '1000';

              // Add menu options
              const flatPathOption = document.createElement('div'); 
              flatPathOption.className = 'kintegrate-context-option';
              flatPathOption.textContent = '↔ Insert flat path: ' + buildHandlebarsPath(node.path, node);
              flatPathOption.addEventListener('click', () => {
                  templateEditor.replaceSelection(`{{${buildHandlebarsPath(node.path, node)}}}`);
                  templateEditor.focus();
                  menu.remove();
              });
              menu.appendChild(flatPathOption);

              const treeStructOption = document.createElement('div');  
              treeStructOption.className = 'kintegrate-context-option';
              treeStructOption.textContent = '⤡ Insert tree structure';
              treeStructOption.addEventListener('click', () => {
                  const treeStr = buildHandlebarsTree(node);
                  if (treeStr) {
                      templateEditor.replaceSelection(treeStr);
                      templateEditor.focus();
                  }
                  menu.remove();
              });
              menu.appendChild(treeStructOption);

              // Add context boundary option
              const contextBoundaryOption = document.createElement('div');
              contextBoundaryOption.className = 'kintegrate-context-option';
              const isCurrentlyBoundary = treeInstance.isContextBoundary(nodeId);
              contextBoundaryOption.textContent = (isCurrentlyBoundary ? '✓ Remove' : '⬚√ Set') + ' as context boundary';
              contextBoundaryOption.addEventListener('click', () => {
                  const newState = !treeInstance.isContextBoundary(nodeId);
                  treeInstance.setContextBoundary(nodeId, newState);
                  el.classList.toggle('context-boundary', newState);
                  menu.remove();
              });
              menu.appendChild(contextBoundaryOption);
              
              // Add the menu to the document
              document.body.appendChild(menu);

              // Ensure menu is visible within viewport
              const menuRect = menu.getBoundingClientRect();
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              
              if (menuRect.right > viewportWidth) {
                  menu.style.left = (viewportWidth - menuRect.width - 10) + 'px';
              }
              if (menuRect.bottom > viewportHeight) {
                  menu.style.top = (viewportHeight - menuRect.height - 10) + 'px';
              }

              // Handle menu removal
              const removeMenu = () => {
                  if (menu && menu.parentNode) {
                      menu.parentNode.removeChild(menu);
                  }
                  document.removeEventListener('click', removeMenu);
                  document.removeEventListener('mousemove', trackMouse);
              };

              // Track mouse movement
              const trackMouse = (e) => {
                  if (!menu) return;
                  const rect = menu.getBoundingClientRect();
                  const buffer = 10; // 10px buffer zone
                  
                  if (e.clientX < rect.left - buffer || 
                      e.clientX > rect.right + buffer || 
                      e.clientY < rect.top - buffer || 
                      e.clientY > rect.bottom + buffer) {
                      removeMenu();
                  }
              };

              // Set up event listeners for menu removal
              document.addEventListener('click', removeMenu);
              document.addEventListener('mousemove', trackMouse);
          });
          //***************************

          // Update tree depth slider display
          if (treeDepthControl && document.getElementById('depth-value')) {
            const value = parseInt(treeDepthControl.value);
            const depth = value === 6 ? 0 : value;
            document.getElementById('depth-value').textContent = depth === 0 ? 'All' : depth;
          }

          console.log('Tree rendering complete, checking wrapper...');
          // Ensure wrapper exists after tree is rendered
          setTimeout(() => {
            console.log('Delayed wrapper check...');
            ensureTreeWrapper();
          }, 100);

          // Initialize the tree size slider
          const treeSizeSlider = document.getElementById('tree-size-slider');
          const sizeValue = document.getElementById('size-value');
          if (treeSizeSlider && sizeValue) {
            const value = parseInt(treeSizeSlider.value);
            sizeValue.textContent = value + '%';
            const treeContainer = document.getElementById('json-tree-container');
            if (treeContainer) {
              const wrapper = treeContainer.querySelector('.tree-scale-wrapper');
              if (wrapper) {
                const scale = value / 100;
                wrapper.style.transform = `scale(${scale})`;
              }
            }
          }

          } catch (e) {
            // Display error in the tree container
            jsonTreeContainer.innerHTML = `
              <div style="color: red; padding: 10px; border: 1px solid red; margin: 10px; background-color: #fff0f0;">
                <strong>Invalid JSON</strong><br>
                <pre style="margin-top: 8px; white-space: pre-wrap;">${e.message}</pre>
              </div>`;
            
            // Also update the selected paths area to show no selection
            const selectedPaths = document.getElementById('selected-paths');
            if (selectedPaths) {
              selectedPaths.innerHTML = 'No nodes selected. (Fix JSON syntax error to enable selection)';
            }
            
            // Hide the actions area since we can't select anything
            const actionsWrap = document.querySelector('.tree-actions');
            if (actionsWrap) {
              actionsWrap.style.display = 'none';
            }
          }
      }

      function insertSelectedPathsAtCursor() {
        if (!selectedPaths || selectedPaths.length === 0) return;
        const inserts = selectedPaths.map(p => `{{${buildHandlebarsPath(p)}}}`);
        templateEditor.replaceSelection(inserts.join('\n'));
        templateEditor.focus();
      };
      
      // Load intro.json by default
      fetch('example/instance/intro.json')
        .then(response => response.ok ? response.text() : Promise.reject('Network response was not ok'))
        .then(data => {
          inputEditor.setValue(data);
          updateJsonTree(data);
          // Run initial conversion since auto-convert is enabled by default
          runConversion();
        })
        .catch(error => {
          console.error('Error loading intro.json:', error);
          // Fallback to empty JSON if file can't be loaded
          inputEditor.setValue('{}');
          // Run initial conversion even with empty data
          runConversion();
        });
      outputEditor.setValue('Output goes here after conversion is run.');

      // --- Event Handlers ---
      // We use auto-convert now, no manual conversion button needed

      // File input handling
      document.getElementById('fileInput').addEventListener('change', function(ev) {
        const file = ev.target.files && ev.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const content = e.target.result;
            inputEditor.setValue(content);
            updateJsonTree(content);
            // Run conversion immediately if auto-convert is enabled
            if (autoConvertEnabled) {
              runConversion();
            }
          };
          reader.readAsText(file);
        }
      });

      // Example selection
      document.getElementById('exampleSelect').addEventListener('change', function() {
        const selectedFile = this.value;
        if (selectedFile) {
          fetch(`example/instance/${selectedFile}`)
            .then(response => response.ok ? response.text() : Promise.reject('Network response was not ok'))
            .then(data => {
              inputEditor.setValue(data);
              updateJsonTree(data);
              // Run conversion immediately if auto-convert is enabled
              if (autoConvertEnabled) {
                runConversion();
              }
            })
            .catch(error => {
              console.error('There was a problem with the fetch operation:', error);
              const msg = 'Error loading file: ' + selectedFile;
              inputEditor.setValue(JSON.stringify({ error: msg }, null, 2));
            });
        }
      });

      // Conversion is now handled by auto-convert functionality

      // when show-compiled button is clicked, show the compiled template
/*      var showPreCompiledButton = document.getElementById('show-compiled');
      showPreCompiledButton.addEventListener('click', () => {
        const templateString = templateEditor.getValue();
        try {
          var precompiledTemplate = Handlebars.precompile ? Handlebars.precompile(templateString) : 'Precompile not available';
          const precompileContainer = document.getElementById('precompile-container');
          const compiledTextarea = document.createElement('textarea');
          compiledTextarea.id = 'precompiled-textarea';
          compiledTextarea.style.width = '100%';
          compiledTextarea.style.height = '50%';
          compiledTextarea.readOnly = true;
          compiledTextarea.value = precompiledTemplate;
          precompileContainer.appendChild(showPreCompiledButton);
          showPreCompiledButton.style.display = 'none'; // hide the button after click
          // add a copy to cli§pboard button to the alert that copies the template to clipboard
          const copyButton = document.createElement('button');
          copyButton.textContent = 'Copy precompiled template to Clipboard (+close)';
          copyButton.id = 'copy-precompiled-button';
          precompileContainer.appendChild(copyButton);
          copyButton.style.cursor = 'pointer';
          copyButton.onclick = () => {
            navigator.clipboard.writeText(precompiledTemplate).then(() => {
              // show text "Copied!" on the button for 1 second then remove the textarea and copy button;
              copyButton.textContent = 'Copied!';
              setTimeout(() => {
                precompileContainer.removeChild(compiledTextarea);
                precompileContainer.removeChild(copyButton);
                showPreCompiledButton.style.display = 'inline'; // show the show-compiled button again
              }, 1000);
            });
          };
        } catch (e) {
          alert('Error during precompilation:\n\n' + e.message);
          console.error('Precompilation Error:', e);
        }
      });

      // When content of template-editor changes: If compiled-textarea exists, remove it + copy button and show the show-compiled button again
      templateEditor.on('change', () => {
        console.log("Template editor changed, removing precompiled view if exists.");
        const precompileContainer = document.getElementById('conversion-container');
        const compiledTextarea = document.getElementById('precompiled-textarea');
        const copyButton = document.getElementById('copy-precompiled-button');
        if (compiledTextarea && copyButton) {
          precompileContainer.removeChild(compiledTextarea);
          precompileContainer.removeChild(copyButton);
          showPreCompiledButton.style.display = 'inline'; // show the show-compiled button again
        }
      });
*/
      document.getElementById('toggle-line-numbers').addEventListener('change', function() {
        const showLineNumbers = this.checked;
        const editors = [inputEditor, templateEditor, outputEditor];
        editors.forEach(editor => editor.setOption('lineNumbers', showLineNumbers));
      });

      // Update tree and run conversion when user types in the input editor
      inputEditor.on('change', (editor) => {
        updateJsonTree(editor.getValue());
        // Run auto-convert if enabled
        if (autoConvertEnabled) {
          const delay = parseInt(autoConvertDelay.value, 10) || 500;
          debounce(runConversion, delay)();
        }
      });

      }); // DOMContentLoaded
    </script>
  </body>
</html>
